{"version":3,"file":"PRIVATE_meterUtils.js","sources":["../../../src/utils/PRIVATE_meterUtils/meterUtils.ts","../../../src/utils/PRIVATE_meterUtils/circleUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Threshold, ThresholdDisplay } from '../UNSAFE_meterTypes';\n\n/**\n * Validates the min, max, value and step passed to the meter are in appropriate range.\n * @throws { RangeError }\n * @param min The minimum value of the meter.\n * @param max The maximum value of the meter.\n * @param value The metric value of the meter.\n * @param step The step value of the meter.\n */\nexport function validateRange(min: number, max: number, value: number, step: number): void {\n  if (min > max) {\n    throw new RangeError('The min must be lower or equal to max.');\n  }\n\n  if (value < min || value > max) {\n    throw new RangeError('The value must be between min and max.');\n  }\n\n  if (step > max - min) {\n    throw new RangeError('The step value must be less than the difference of max and min');\n  }\n}\n\n/**\n * Returns the threshold that the current value belongs to. Returns undefined if the current value does not belong to\n * any threshold or if thresholds is undefined.\n * @param value The value in meter.\n * @param thresholds The list of thresholds.\n * @returns The Threshold that current value belongs to.\n */\nfunction findThreshold(value: number, thresholds?: Threshold[]): Threshold | undefined {\n  if (!thresholds) {\n    return;\n  }\n  if (value <= thresholds[0].max) {\n    return thresholds[0];\n  }\n  let minValue = thresholds[0].max;\n  for (let i = 1; i < thresholds.length; i++) {\n    if (minValue < value && value <= thresholds[i].max) {\n      return thresholds[i];\n    }\n    minValue = thresholds[i].max;\n  }\n  return;\n}\n\n/**\n * Returns the color of track for the meter.\n * @param trackColor The color provided via trackColor prop of the meter.\n * @param thresholdDisplay  Specifies whether current threshold to display in track, indicator or all thresholds in track.\n * @param currentThreshold Current threshold for the meter value.\n * @returns The color of the track for the meter.\n */\nfunction getTrackColor(\n  thresholdDisplay: ThresholdDisplay,\n  currentThreshold: Threshold | undefined,\n  trackColor?: string\n): string | undefined {\n  if (thresholdDisplay === 'track' && currentThreshold?.color) {\n    return currentThreshold?.color;\n  }\n  return trackColor;\n}\n\n/**\n * Returns the color of indicator for the meter.\n * @param indicatorColor The color provided via indicatorColor prop of the meter.\n * @param thresholdDisplay  Specifies whether current threshold to display in track, indicator or all thresholds in track.\n * @param currentThreshold Current threshold for the meter value.\n * @returns The color of the indicator of the meter.\n */\nfunction getIndicatorColor(\n  thresholdDisplay: ThresholdDisplay,\n  currentThreshold: Threshold | undefined,\n  indicatorColor?: string\n): string | undefined {\n  if (currentThreshold?.color && thresholdDisplay === 'indicator') {\n    return currentThreshold.color;\n  }\n  return indicatorColor;\n}\n\n/**\n * Returns the color of track and indicator of the meter.\n * @param value The value of the meter.\n * @param trackColor The color provided via trackColor prop.\n * @param indicatorColor The color provided via indicatorColor prop.\n * @param thresholdDisplay Specifies whether current threshold to display in track, indicator or all thresholds in track.\n * @param thresholds The thresholds for metric value of the meter.\n * @returns The color of the indicator and track of the meter.\n */\nexport function getTrackAndIndicatorColor(\n  value: number,\n  thresholdDisplay: ThresholdDisplay,\n  trackColor?: string,\n  indicatorColor?: string,\n  thresholds?: Threshold[]\n): {\n  trackColor?: string;\n  indicatorColor?: string;\n} {\n  const currentThreshold = findThreshold(value, thresholds);\n  return {\n    trackColor: getTrackColor(thresholdDisplay, currentThreshold, trackColor),\n    indicatorColor: getIndicatorColor(thresholdDisplay, currentThreshold, indicatorColor)\n  };\n}\n\n/**\n * Returns the aria properties of the meter bar.\n * @param value The value of the meter bar.\n * @param min The minimum value of the meter bar.\n * @param max The maximum value of the meter bar.\n * @param valueText The default aria value text for the meter bar.\n * @param accessibleLabel The aria label of the meter bar.\n * @param ariaLabelledby The ariaLabelledBy of the meter bar.\n * @param thresholds The thresholds values for the meter bar.\n * @returns The aria properties of the meter\n */\nexport function getMeterAriaProps(\n  value: number,\n  min: number,\n  max: number,\n  valueText?: string,\n  accessibleLabel?: string,\n  ariaLabelledby?: string,\n  thresholds?: Threshold[]\n): {\n  'aria-label'?: string;\n  'aria-valuenow': string;\n  'aria-valuemin': string;\n  'aria-valuetext': string;\n  'aria-valuemax': string;\n  'aria-labelledby'?: string;\n} {\n  const currentThreshold = findThreshold(value, thresholds);\n  const ariaValueText = `${valueText} ${currentThreshold?.accessibleLabel || ''}`;\n  return {\n    'aria-label': accessibleLabel,\n    'aria-valuenow': `${value}`,\n    'aria-valuemin': `${min}`,\n    'aria-valuetext': ariaValueText,\n    'aria-valuemax': `${max}`,\n    'aria-labelledby': ariaLabelledby\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport type Sector = 'top' | 'bottom' | 'left' | 'right' | 'full';\n\n/**\n * Returns the angle in radians\n * @param angle The angle in degrees.\n * @returns The angle in radians.\n */\nfunction toRad(angle: number): number {\n  return (angle * Math.PI) / 180;\n}\n\n/**\n * Returns equivalent angle between 0 and 360 (exclusive) corresponding to given angle.\n * @param angle The angle in degrees.\n * @returns Returns the posiive angle for a given angle.\n */\nexport function getPositiveAngle(angle: number): number {\n  return (angle + 360) % 360;\n}\n\n/**\n * Returns the polar coordinate of point (x,y) relative to center (cx, cy)\n * @param cx The x coordinate of the center.\n * @param cy The y coordinate of the center.\n * @param x  The x coordinate of the point.\n * @param y  The y coordinate of the point.\n * @returns The polar coordinate of point (x,y) relative to center (cx, cy)\n */\nexport function convertToPolar(\n  cx: number,\n  cy: number,\n  x: number,\n  y: number\n): { radius: number; angle: number } {\n  return {\n    radius: Math.sqrt((x - cx) ** 2 + (y - cy) ** 2),\n    angle: (Math.atan2(cy - y, x - cx) * 180) / Math.PI\n  };\n}\n\n/**\n * Transforms the coordinate x, y in a unit square to the coordinates in given half sector. For eg, (0.5, 0.5) in full\n * unit square will be (0.5, 1) in top half and (0.5, 0) for bottom half.\n * @param x The x coordinate of the point.\n * @param y The y coordinate of the point.\n * @param sector The Sector to trasform\n * @returns The coordinate of point relative to center of the sector.\n */\nfunction transformCoord(x: number, y: number, sector: Sector): { x: number; y: number } {\n  switch (sector) {\n    case 'top':\n      y = 2 * y;\n      break;\n    case 'bottom':\n      y = 2 * y - 1;\n      break;\n    case 'left':\n      x = 2 * x;\n      break;\n    case 'right':\n      x = 2 * x - 1;\n      break;\n  }\n  return { x, y };\n}\n\n/**\n * For a given angle and section, returns the relative coordinate of the point where the radius for\n * the angle intersects the bounding box.\n * @param angle The angle in degrees\n * @param section The section in which the meter circle lies.\n * @returns The relative coordinate of point of intersection of radius and bounding box.\n */\nfunction getPolygonCoord(angle: number, section: Sector): { x: number; y: number } {\n  angle = getPositiveAngle(angle);\n  let x, y;\n  if (angle < 45) {\n    y = 0.5 - 0.5 * Math.tan(toRad(angle));\n    x = 1;\n  } else if (angle < 135) {\n    if (angle < 90) {\n      x = 0.5 + 0.5 * Math.tan(toRad(90 - angle));\n    } else {\n      x = 0.5 - 0.5 * Math.tan(toRad(angle - 90));\n    }\n    y = 0;\n  } else if (angle < 225) {\n    if (angle < 180) {\n      y = 0.5 - 0.5 * Math.tan(toRad(180 - angle));\n    } else {\n      y = 0.5 + 0.5 * Math.tan(toRad(angle - 180));\n    }\n    x = 0;\n  } else if (angle < 315) {\n    if (angle < 270) {\n      x = 0.5 - 0.5 * Math.tan(toRad(270 - angle));\n    } else {\n      x = 0.5 + 0.5 * Math.tan(toRad(angle - 270));\n    }\n    y = 1;\n  } else {\n    x = 1;\n    y = 0.5 + 0.5 * Math.tan(toRad(360 - angle));\n  }\n\n  return transformCoord(x, y, section);\n}\n\n/**\n * Returns the relative coordinate of the center of the half/full circle in which the meter circle lies.\n * @param sector The section in which the meter circle lies.\n * @returns The relative coordinate of the center.\n */\nexport function getCenterCoord(sector: Sector): { x: number; y: number } {\n  return transformCoord(0.5, 0.5, sector);\n}\n\n/**\n * Returns whether the angle lies on top half of the circle\n * @param angle The angle in degrees\n * @returns Whether the angle lies on top half of the circle.\n */\nfunction OnTopHalf(angle: number): boolean {\n  return angle <= 180;\n}\n\n/**\n * Returns whether the angle lies on right half of the circle\n * @param angle The angle in degrees\n * @returns Whether the angle lies on right half of the circle.\n */\nfunction OnRightHalf(angle: number): boolean {\n  return angle <= 90 || angle >= 270;\n}\n\n/**\n * Returns whether the angle lies on left half of the circle\n * @param angle The angle in degrees\n * @returns Whether the angle lies on left half of the circle.\n */\nfunction OnLeftHalf(angle: number): boolean {\n  return angle >= 90 && angle <= 270;\n}\n\n/**\n * Returns whether the angle lies on bottom half of the circle\n * @param angle The angle in degrees\n * @returns Whether the angle lies on bottom half of the circle.\n */\nfunction OnBottomHalf(angle: number): boolean {\n  return angle >= 180 || angle === 0;\n}\n\n/**\n * Returns the Sector the meter circle lies on.\n * @param startAngle The start angle.\n * @param angleExtent The angle extent.\n * @param isRtl If the reading mode is rtl\n * @returns Which half the meter circle lies on.\n */\nexport function getCircleSection(startAngle: number, angleExtent: number, isRtl: boolean): Sector {\n  if (angleExtent > 180) {\n    return 'full';\n  }\n\n  const meanAngle = getPositiveAngle(startAngle + (isRtl ? 0.5 : -0.5) * angleExtent);\n  const endAngle = getPositiveAngle(startAngle + (isRtl ? 1 : -1) * angleExtent);\n\n  if (OnTopHalf(startAngle) && OnTopHalf(meanAngle) && OnTopHalf(endAngle)) {\n    return 'top';\n  } else if (OnRightHalf(startAngle) && OnRightHalf(meanAngle) && OnRightHalf(endAngle)) {\n    return 'right';\n  } else if (OnLeftHalf(startAngle) && OnLeftHalf(meanAngle) && OnLeftHalf(endAngle)) {\n    return 'left';\n  } else if (OnBottomHalf(startAngle) && OnBottomHalf(meanAngle) && OnBottomHalf(endAngle)) {\n    return 'bottom';\n  }\n  return 'full';\n}\n\n/**\n * Returns the clip polygon for given startAngle and angleExtent.\n * @param startAngle The start angle of arc in degrees.\n * @param angleExtent The angle extent of arc in degrees.\n * @param isRtl  The reading mode of the document.\n * @param section The Sector circular meter lies on.\n * @returns The clippath for given startAngle and angleExtent\n */\nexport function getClipPath(\n  startAngle: number,\n  angleExtent: number,\n  isRtl: boolean,\n  section: Sector\n): string {\n  let start = isRtl ? startAngle + angleExtent : startAngle;\n  const firstVertexCoords = getPolygonCoord(start, section);\n  let clipPath = `${firstVertexCoords.x * 100}% ${firstVertexCoords.y * 100}%`;\n  let nextVertex, nextVertexCoords;\n  do {\n    nextVertex = Math.max(start - angleExtent, 45 * (Math.ceil(start / 45) - 1));\n    nextVertexCoords = getPolygonCoord(nextVertex, section);\n    clipPath += `, ${nextVertexCoords.x * 100}% ${nextVertexCoords.y * 100}%`;\n    angleExtent = angleExtent - (start - nextVertex);\n    start = nextVertex;\n  } while (nextVertex > start - angleExtent);\n\n  const centerVertex = getCenterCoord(section);\n  // close the polygon with a vertex in center to get the radial clipping\n  return `polygon(${clipPath}, ${centerVertex.x * 100}% ${centerVertex.y * 100}%)`;\n}\n"],"names":["findThreshold","value","thresholds","max","minValue","i","length","getTrackColor","thresholdDisplay","currentThreshold","trackColor","color","getIndicatorColor","indicatorColor","toRad","angle","Math","PI","getPositiveAngle","transformCoord","x","y","sector","getPolygonCoord","section","tan","getCenterCoord","OnTopHalf","OnRightHalf","OnLeftHalf","OnBottomHalf","cx","cy","radius","sqrt","atan2","startAngle","angleExtent","isRtl","meanAngle","endAngle","start","firstVertexCoords","nextVertex","nextVertexCoords","clipPath","ceil","centerVertex","min","valueText","accessibleLabel","ariaLabelledby","step","RangeError"],"mappings":"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"}