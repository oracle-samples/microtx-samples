{"version":3,"file":"useFocusWithin-2efc86a8.js","sources":["../../src/hooks/UNSAFE_useFocusWithin/useFocusWithin.ts"],"sourcesContent":["import { useCallback, useRef, useState } from 'preact/hooks';\n\ntype FocusEvents = {\n  onBlurWithin?: (e: FocusEvent) => void;\n  onFocusWithin?: (e: FocusEvent) => void;\n};\n\ntype UseFocusWithinProps = FocusEvents & {\n  isDisabled?: boolean;\n};\n\nexport function useFocusWithin({\n  isDisabled,\n  onBlurWithin,\n  onFocusWithin\n}: UseFocusWithinProps = {}) {\n  const [isFocused, setIsFocused] = useState(false);\n  // Maintain a ref for whether we're focused so that we can update it synchronously and check\n  // it in the listeners.  It's possible for an element to receive and lose focus before\n  // the next render happens, in which case the isFocused state hasn't been updated yet for\n  // the focusin event.  The focusout listener would not do anything based on that stale state,\n  // which would result in the isFocused state incorrectly remaining true.\n  // We still need the isFocused state because that state change will trigger a rerender,\n  // whereas updating the ref will not.\n  const isFocusedRef = useRef(false);\n  const onfocusin = useCallback(\n    (event: FocusEvent) => {\n      if (!isFocusedRef.current) {\n        onFocusWithin?.(event);\n        setIsFocused(true);\n        isFocusedRef.current = true;\n      }\n    },\n    [onFocusWithin]\n  );\n  const onfocusout = useCallback(\n    (event: FocusEvent) => {\n      // Trigger focus event changes only when the focus goes outside of the current\n      // target. Ignore focus changes within the current target\n      if (\n        isFocusedRef.current &&\n        (event.relatedTarget == null ||\n          !(event.currentTarget as HTMLElement).contains(event.relatedTarget as HTMLElement))\n      ) {\n        onBlurWithin?.(event);\n        setIsFocused(false);\n        isFocusedRef.current = false;\n      }\n    },\n    [onBlurWithin]\n  );\n\n  return isDisabled\n    ? {\n        isFocused: false,\n        focusProps: {}\n      }\n    : {\n        isFocused,\n        focusProps: {\n          onfocusin,\n          onfocusout\n        }\n      };\n}\n"],"names":["isDisabled","onBlurWithin","onFocusWithin","isFocused","setIsFocused","useState","isFocusedRef","useRef","onfocusin","useCallback","event","current","onfocusout","relatedTarget","currentTarget","contains","focusProps"],"mappings":"8EAWM,UAAyBA,WAC7BA,EAD6BC,aAE7BA,EAF6BC,cAG7BA,GACuB,IACvB,MAAOC,EAAWC,GAAgBC,EAAQA,UAAC,GAQrCC,EAAeC,UAAO,GACtBC,EAAYC,cACfC,IACMJ,EAAaK,UAChBT,MAAAA,GAAAA,EAAgBQ,GAChBN,GAAa,GACbE,EAAaK,SAAU,IAG3B,CAACT,IAEGU,EAAaH,cAChBC,KAIGJ,EAAaK,SACW,MAAvBD,EAAMG,eACHH,EAAMI,cAA8BC,SAASL,EAAMG,iBAEvDZ,MAAAA,GAAAA,EAAeS,GACfN,GAAa,GACbE,EAAaK,SAAU,IAG3B,CAACV,IAGH,OAAOD,EACH,CACEG,WAAW,EACXa,WAAY,IAEd,CACEb,UAAAA,EACAa,WAAY,CACVR,UAAAA,EACAI,WAAAA"}