{"version":3,"file":"FilePicker-5e3c00f7.js","sources":["../../src/UNSAFE_FilePicker/FilePickerUtils.tsx","../../src/UNSAFE_FilePicker/postValidationUtils.tsx","../../src/UNSAFE_FilePicker/useFilePickerElement.tsx","../../src/UNSAFE_FilePicker/FilePicker.tsx"],"sourcesContent":["import { ComponentMessageItem } from '../UNSAFE_ComponentMessage';\nimport { Text } from '../UNSAFE_Text';\nimport { Spacer } from '../UNSAFE_Spacer';\nimport { sizeToCSS } from '../utils/UNSAFE_size';\nimport { trim } from '../utils/UNSAFE_stringUtils';\nimport { BundleType } from '../resources/nls/bundle';\n\nimport { FilePicker } from './FilePicker';\n\nimport { JSX, ComponentProps } from 'preact';\n\ntype FilePickerProps = ComponentProps<typeof FilePicker>;\n\n/**\n * Gets the default content of the file picker\n */\nexport const getDefaultTriggerContent = (\n  isDisabled: FilePickerProps['isDisabled'],\n  primaryText: FilePickerProps['primaryText'],\n  secondaryText: FilePickerProps['secondaryText'],\n  translations: BundleType,\n  selectionMode: FilePickerProps['selectionMode']\n) => {\n  return [\n    <Text variant={isDisabled ? 'disabled' : 'primary'} weight=\"bold\" size=\"xl\">\n      {getPrimaryText(primaryText, translations)}\n    </Text>,\n    <Spacer height=\"1.5x\"></Spacer>,\n    <Text variant={isDisabled ? 'disabled' : 'secondary'} size=\"sm\">\n      {getSecondaryText(secondaryText, translations, selectionMode)}\n    </Text>\n  ];\n};\n\n/**\n * Returns the aria label\n */\ntype AriaLabelProps = {\n  accessibleLabel: FilePickerProps['accessibleLabel'];\n  isDisabled: FilePickerProps['isDisabled'];\n  translations: BundleType;\n  primaryText?: FilePickerProps['primaryText'];\n  secondaryText?: FilePickerProps['secondaryText'];\n  selectionMode?: FilePickerProps['selectionMode'];\n};\nexport const getAriaLabel = ({\n  accessibleLabel,\n  isDisabled,\n  translations,\n  primaryText,\n  secondaryText,\n  selectionMode\n}: AriaLabelProps) => {\n  return accessibleLabel\n    ? accessibleLabel\n    : `${isDisabled ? '' : translations.filePicker_addFiles() + '. '}${getPrimaryText(\n        primaryText,\n        translations\n      )}. ${getSecondaryText(secondaryText, translations, selectionMode)}`;\n};\n\n/**\n * Returns the styles of the file picker\n */\nexport const getStyles = (width: FilePickerProps['width'], height: FilePickerProps['height']) => {\n  const dimStyles: JSX.CSSProperties = {\n    width: width ? sizeToCSS(width) : undefined,\n    height: height ? sizeToCSS(height) : undefined\n  };\n  return dimStyles;\n};\n\n/**\n * Returns the primary text\n */\nconst getPrimaryText = (primaryText: FilePickerProps['primaryText'], translations: BundleType) => {\n  return primaryText ? primaryText : translations.filePicker_dropzonePrimaryText();\n};\n\n/**\n * Returns the secondary text text\n */\nconst getSecondaryText = (\n  secondaryText: FilePickerProps['secondaryText'],\n  translations: BundleType,\n  selectionMode: FilePickerProps['selectionMode']\n) => {\n  const defaultSecondaryText =\n    selectionMode === 'multiple'\n      ? translations.filePicker_dropzoneSecondaryTextMultiple()\n      : translations.filePicker_dropzoneSecondaryText();\n  return secondaryText ? secondaryText : defaultSecondaryText;\n};\n\n/**\n * Takes in a list of files and returns a list of accepted files and\n * a list of rejected files based on file type\n */\nexport const validateTypes = (\n  files: FileList,\n  accept: FilePickerProps['accept'],\n  translations: BundleType\n) => {\n  const accepted = [];\n  const rejected = [];\n  let file: File;\n  let type: string;\n  if (files) {\n    for (let i = 0; i < files.length; i++) {\n      file = files[i];\n      const name = file.name;\n      type = translations.filePicker_unknownFileTypeUploadError();\n      if (name) {\n        const nameSplit = name.split('.');\n        type = nameSplit.length > 1 ? '.' + nameSplit.pop() : type;\n      }\n      type = file.type ? file.type : type;\n      // If type isn't already in one of the lists, add it\n      if (accepted.indexOf(type) === -1 && rejected.indexOf(type) === -1) {\n        if (_acceptFile(file, accept)) {\n          accepted.push(type);\n        } else {\n          rejected.push(type);\n        }\n      }\n    }\n  }\n  return { accepted, rejected };\n};\n\n/**\n * Creates a file list\n */\nexport const createFileList = (origList: FileList | DataTransferItemList) => {\n  const descriptor: Record<string | number, PropertyDescriptor> = {\n    length: { value: origList.length },\n    item: {\n      value(index: number): File {\n        return (this as unknown as FileList)[index];\n      }\n    }\n  };\n  for (let i = 0; i < origList.length; i++) {\n    descriptor[i] = { value: origList[i], enumerable: true };\n  }\n\n  return Object.create(FileList.prototype, descriptor);\n};\n\n/**\n * Returns false if selected multiple files when in single file selection mode\n */\nexport const validateSelectionMode = (\n  files: FileList,\n  selectionMode: FilePickerProps['selectionMode']\n) => {\n  return selectionMode !== 'single' || files.length === 1;\n};\n\n/**\n * Returns the correct message if mime type validation has failed\n */\nexport const getMimeTypeValidationMessages = (\n  rejected: Array<string>,\n  translations: BundleType\n): ComponentMessageItem[] => {\n  const messages: ComponentMessageItem[] = [];\n  if (rejected.length === 1) {\n    messages.push({\n      severity: 'error',\n      summary: translations.filePicker_singleTypeUploadError({\n        fileType: rejected[0]\n      })\n    });\n  } else {\n    messages.push({\n      severity: 'error',\n      summary: translations.filePicker_multipleFileTypeUploadError({\n        fileTypes: rejected.join(translations.plural_separator())\n      })\n    });\n  }\n  return messages;\n};\n\n/**\n * Returns true if file passes mimetype validation\n */\nconst _acceptFile = (file: File, accept: FilePickerProps['accept']) => {\n  const acceptProp = accept;\n  if (!acceptProp || acceptProp.length === 0 || !file) {\n    return true;\n  }\n\n  let fileAccept;\n  for (let i = 0; i < acceptProp.length; i++) {\n    fileAccept = trim(acceptProp[i]) as string;\n    if (!fileAccept) {\n      return true;\n    } else if (fileAccept.startsWith('.', 0)) {\n      // when dragover, only MIME type is available, file name is undefined\n      // to lowerCase is to make the string comparison case insensitive\n      if (!file.name || (file.name && file.name.toLowerCase().endsWith(fileAccept.toLowerCase()))) {\n        return true;\n      }\n    } else if (!file.type) {\n      return false;\n    } else if (fileAccept === 'image/*') {\n      if (file.type.startsWith('image/', 0)) {\n        return true;\n      }\n    } else if (fileAccept === 'video/*') {\n      if (file.type.startsWith('video/', 0)) {\n        return true;\n      }\n    } else if (fileAccept === 'audio/*') {\n      if (file.type.startsWith('audio/', 0)) {\n        return true;\n      }\n    } else if (file.type === fileAccept) {\n      return true;\n    }\n  }\n  return false;\n};\n","import { ComponentMessageItem } from '../UNSAFE_ComponentMessage';\n\nimport { createFileList } from './FilePickerUtils';\nimport { RejectDetail, CommitDetail } from './FilePicker';\n\n/**\n * Calls the onReject callback when invalid files are selected.\n * For invalid dragged files, this function will return a promise resolver that\n * should be called when the invalid files are no longer dragged over the filepicker.\n */\nexport const fireRejectAction = (\n  messages: ComponentMessageItem[],\n  isDrag: boolean,\n  onReject?: (detail: RejectDetail) => void\n) => {\n  let resolver;\n  const dragPromise = isDrag\n    ? new Promise<void>((resolve) => {\n        resolver = resolve;\n      })\n    : null;\n\n  onReject?.({\n    messages,\n    until: dragPromise\n  });\n  return resolver;\n};\n\n/**\n * Calls the onCommit callback when all files are valid.\n */\nexport const handleFilesAdded = (files: FileList, onCommit?: (detail: CommitDetail) => void) => {\n  // Bug 28503874 - filepicker: filelist cleared after the handler returns\n  // Note: the parameter \"files\" is a direct reference to the embedded Input element's property\n  // which could be reset or changed.\n  // we need to return a copy of FileList just in case apps hold on to a reference to FileList\n  const list = createFileList(files);\n  onCommit?.({\n    files: list\n  });\n};\n","import { pickFiles } from '../utils/UNSAFE_filePickerUtils';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { usePress } from '../hooks/UNSAFE_usePress';\nimport { useHover } from '../hooks/UNSAFE_useHover';\nimport { ComponentMessageItem } from '../UNSAFE_ComponentMessage';\nimport { BundleType } from '../resources/nls/bundle';\n\nimport { FilePicker, CommitDetail, RejectDetail } from './FilePicker';\nimport {\n  validateTypes,\n  getMimeTypeValidationMessages,\n  createFileList,\n  validateSelectionMode\n} from './FilePickerUtils';\nimport { fireRejectAction, handleFilesAdded } from './postValidationUtils';\n\nimport { ComponentProps } from 'preact';\nimport { useRef, Ref, StateUpdater } from 'preact/hooks';\n\ntype FilePickerProps = ComponentProps<typeof FilePicker>;\n\ntype FilePickerElementProps = FilePickerProps & {\n  translations: BundleType;\n};\n\n/**\n * The file picker helper method for non-disabled filepickers.\n */\nexport const useFilepickerElementHelper = (\n  props: FilePickerElementProps,\n  rootRef: Ref<HTMLDivElement>,\n  setValidity?: StateUpdater<'NA' | 'valid' | 'invalid'>\n) => {\n  const { callback, validation } = clickCallbackUtils(props);\n  const { pressProps } = usePress(callback);\n\n  const dragAndDropProps = useDragAndDropEvents(\n    props.accept,\n    props.selectionMode,\n    fireRejectAction,\n    handleFilesAdded,\n    rootRef,\n    props.translations,\n    props.onCommit,\n    props.onReject,\n    setValidity\n  );\n  const { hoverProps, isHover } = useHover({ isDisabled: false });\n  return {\n    validation,\n    dragAndDropProps,\n    pressProps,\n    isHover,\n    hoverProps\n  };\n};\n\ntype ClickProps = {\n  accept?: FilePickerProps['accept'];\n  capture?: FilePickerProps['capture'];\n  selectionMode?: FilePickerProps['selectionMode'];\n  onCommit?: FilePickerProps['onCommit'];\n  onReject?: FilePickerProps['onReject'];\n  translations: BundleType;\n};\n\nconst clickCallbackUtils = (props: ClickProps) => {\n  /**\n   * Callback function when the filepicker is clicked.\n   */\n  const handleSelectingFiles = (event: Event) => {\n    // Bug 27775173 - within firefox browser cannot tab past filepicker without file selector\n    // window opening\n    // only launching the file picker if click or 'Enter' was pressed\n    if (\n      event.type === 'click' ||\n      (event.type === 'keyup' && (event as KeyboardEvent).code === 'Enter')\n    ) {\n      // Bug 26907138 - form submit event is triggered when the file upload button is clicked\n      event.preventDefault();\n\n      pickFiles(_handleClickValidation, {\n        accept: props.accept,\n        selectionMode: props.selectionMode ?? 'multiple',\n        capture: props.capture ?? 'none'\n      });\n    }\n  };\n\n  /**\n   * Handles file validation from selecting files through the file dialog\n   */\n  const _handleClickValidation = (files: FileList) => {\n    if (files.length > 0) {\n      const rejected = validateTypes(files, props.accept, props.translations).rejected;\n      if (rejected.length > 0) {\n        fireRejectAction(\n          getMimeTypeValidationMessages(rejected, props.translations),\n          false,\n          props.onReject\n        );\n      } else {\n        handleFilesAdded(files, props.onCommit);\n      }\n    }\n  };\n  return {\n    callback: handleSelectingFiles,\n    validation: _handleClickValidation\n  };\n};\n\nconst useDragAndDropEvents = (\n  accept: FilePickerProps['accept'],\n  selectionMode: FilePickerProps['selectionMode'],\n  fireRejectAction: (\n    messages: ComponentMessageItem[],\n    isDrag: boolean,\n    onReject?: (detail: RejectDetail) => void\n  ) => any,\n  handleFilesAdded: (files: FileList, onCommit?: (detail: CommitDetail) => void) => void,\n  rootRef: Ref<HTMLDivElement>,\n  translations: BundleType,\n  onCommit?: (detail: CommitDetail) => void,\n  onReject?: (detail: RejectDetail) => void,\n  // setValidity not set for custom filepicker\n  setValidity?: StateUpdater<'NA' | 'valid' | 'invalid'>\n) => {\n  const inDropZone = useRef<boolean>(false);\n  const isDroppable = useRef<boolean>(false);\n  const dragPromiseResolver = useRef<() => void>();\n\n  /**\n   * Drag Enter handler called when a dragged file enter the filepicker dropzone\n   */\n  const _handleDragEnter = (event: Event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  /**\n   * Drag over handler called when a file is dragged over the filepicker\n   */\n  const _handleDragOver = (event: DragEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n    if (inDropZone.current) {\n      return;\n    }\n\n    const browser = getClientHints().browser;\n    inDropZone.current = true;\n    isDroppable.current = true;\n    // Safari doesn't provide the data for the files on drag over so validation cannot be done until drop\n    if (browser !== 'safari') {\n      if (!event.dataTransfer) {\n        return;\n      }\n      const files = createFileList(event.dataTransfer.items);\n      let messages = [] as ComponentMessageItem[];\n      const selectionModeValid = validateSelectionMode(files, selectionMode);\n      const droppable = validateTypes(files, accept, translations);\n      if (selectionModeValid && droppable.rejected.length === 0) {\n        // validation passes\n        setValidity?.('valid');\n      } else {\n        isDroppable.current = false;\n        if (selectionModeValid) {\n          // mimetype Validation fails\n          messages = getMimeTypeValidationMessages(droppable.rejected, translations);\n        } else {\n          // selected multiple files in single selection mode\n          messages.push({\n            severity: 'error',\n            summary: translations.filePicker_singleFileUploadError()\n          });\n        }\n        setValidity?.('invalid');\n        dragPromiseResolver.current = fireRejectAction(messages, true, onReject);\n      }\n    } else {\n      setValidity?.('valid');\n    }\n  };\n\n  /**\n   * Drag leave handler is called when the dragged file leaves the filepicker dropzone\n   */\n  const _handleDragLeave = (event: DragEvent, mimeTypeDropFail = false) => {\n    if (!inDropZone.current) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    if (!rootRef.current?.contains(event.relatedTarget as Node)) {\n      inDropZone.current = false;\n      setValidity?.('NA');\n      // There's only a promise if validation failed on dragover\n      if (!isDroppable.current && !mimeTypeDropFail) {\n        dragPromiseResolver.current?.();\n      }\n    }\n  };\n\n  /**\n   * Drop file handler is called when a file is dropped on the filepicker dropzone\n   */\n  const _handleFileDrop = (event: DragEvent) => {\n    if (inDropZone.current) {\n      event.preventDefault();\n      event.stopPropagation();\n      if (!event.dataTransfer) {\n        inDropZone.current = false;\n        return;\n      }\n      const files = createFileList(event.dataTransfer.files);\n      let mimeTypeDropFail = false;\n      if (isDroppable.current) {\n        let messages: ComponentMessageItem[] = [];\n        if (validateSelectionMode(files, selectionMode)) {\n          const droppable = validateTypes(files, accept, translations);\n          if (droppable.rejected.length > 0) {\n            // mimetype Validation fails\n            messages = getMimeTypeValidationMessages(droppable.rejected, translations);\n            mimeTypeDropFail = true;\n          }\n        } else {\n          messages.push({\n            severity: 'error',\n            summary: translations.filePicker_singleFileUploadError()\n          });\n        }\n        if (messages.length > 0) {\n          isDroppable.current = false;\n          fireRejectAction(messages, false, onReject);\n        }\n        if (isDroppable.current) {\n          handleFilesAdded(files, onCommit);\n        }\n      }\n      _handleDragLeave(event, mimeTypeDropFail);\n    }\n  };\n\n  return {\n    onDragEnter: _handleDragEnter,\n    onDragOver: _handleDragOver,\n    onDragLeave: _handleDragLeave,\n    onDrop: _handleFileDrop\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { Size } from '../utils/UNSAFE_size';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\nimport { ComponentMessageItem } from '../UNSAFE_ComponentMessage';\nimport { cssProps } from '@oracle/oraclejet-cssprops';\n\nimport { getDefaultTriggerContent, getAriaLabel, getStyles } from './FilePickerUtils';\nimport { useFilepickerElementHelper } from './useFilePickerElement';\n\nimport { ComponentChildren } from 'preact';\nimport { useState, useRef, useImperativeHandle } from 'preact/hooks';\nimport { ForwardedRef } from 'preact/compat';\nimport { useTabbableMode } from '../hooks/UNSAFE_useTabbableMode';\n\n// TODO: Andy's comment below JET-53230\n// The FilePicker supports two very different use cases: default and custom file pickers. Should we consider dropping the wrapper and instead exporting the two underlying components (with the appropriate property types) directly?\n// If not, perhaps we should look into defining the Props type as a discriminated union such that primaryText/secondaryText props are only valid when children is not specified?\n\ntype Props = {\n  /**\n   * An array of strings of allowed MIME types or file extensions that can be uploaded; this is unlike the accept attribute of the html &lt;input> element that accepts a simple comma-delimited string. If not specified, all file types will be accepted.\n   * <p>Note: If accept is specified, files with empty string type will be rejected if no match found in the \"accept\" value.   */\n  accept?: string[];\n\n  /**\n   * Specifies the preferred facing mode for the device's\n   * <a href=\"https://www.w3.org/TR/html-media-capture/#dom-htmlinputelement-capture\">media capture</a> mechanism;\n   * This is most often used to provide direct camera access on mobile devices.  Note that the accept attribute must\n   * be specified and have an associated capture control type (e.g.[\"image/*\"]) for the capture attribute to take effect.  Support may vary by browser.\n   *\n   */\n  capture?: 'user' | 'environment' | 'implementation' | 'none';\n\n  /**\n   * Disables the filepicker if set to <code class=\"prettyprint\">true</code>.\n   */\n  isDisabled?: boolean;\n\n  /**\n   * The primary text for the default file picker.\n   */\n  primaryText?: string;\n\n  /**\n   * The secondary text for the default file picker.\n   */\n  secondaryText?: string;\n  /**\n   * Whether to allow single or multiple file selection.\n   */\n  selectionMode?: 'multiple' | 'single';\n\n  /**\n   * A label to be used for accessibility purposes.\n   */\n  accessibleLabel?: string;\n\n  /**\n   * Property that triggers a callback immediately when a set of files have been committed\n   */\n  onCommit?: (detail: CommitDetail) => void;\n\n  /**\n   * Property that triggers a callback immediately when a set of files have been rejected\n   */\n  onReject?: (detail: RejectDetail) => void;\n\n  /**\n   * Width of the File Picker\n   */\n  width?: Size;\n\n  /**\n   * Height of the File Picker\n   */\n  height?: Size;\n\n  /**\n   * If the children is provided, its contents replace the default filepicker.  Filepicker will still set role and aria-label, but\n   * the application is responsible for setting the tabindex.\n   */\n  children?: ComponentChildren;\n};\n\nexport type CommitDetail = {\n  files: FileList;\n};\n\nexport type RejectDetail = {\n  /**\n   * Messages that should be displayed to the user (e.g. in an oj-messages component) describing rejected files.\n   */\n  messages: ComponentMessageItem[];\n\n  /**\n   * This property may be populated with a Promise to provide short-term feedback during a user interaction (typically drag and drop); the feedback should be cleared upon the resolution of this Promise.\n   */\n  until: Promise<void> | null;\n};\n\n/**\n * A file picker displays a clickable dropzone for selecting files from the device storage.\n */\nexport function FilePicker({\n  capture = 'none',\n  isDisabled = false,\n  selectionMode = 'multiple',\n  children,\n  ...otherProps\n}: Props) {\n  // this ref is added only for testing purposes.  Allows the test to directly\n  // call certain functions that should be tested\n  const testHandlersRef = (otherProps as any).__testHandlerSymbol;\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const props = { capture, selectionMode, translations, ...otherProps };\n  if (isDisabled) {\n    return <DisabledFilePicker {...props}>{children}</DisabledFilePicker>;\n  }\n  return children ? (\n    <CustomFilePicker testHandlersRef={testHandlersRef} {...props}>\n      {children}\n    </CustomFilePicker>\n  ) : (\n    <DefaultFilePicker testHandlersRef={testHandlersRef} {...props} />\n  );\n}\n\ntype FilePickerProps = Props & {\n  translations: BundleType;\n};\n\ntype DndProps = {\n  onDragEnter: (event: Event) => void;\n  onDragOver: (event: DragEvent) => void;\n  onDragLeave: (event: DragEvent, mimeTypeDropFail: boolean) => void;\n  onDrop: (event: DragEvent) => void;\n};\n\nexport type TestHandlersRef = ForwardedRef<\n  DndProps & {\n    onClickSelected: (files: FileList) => void;\n  }\n>;\n\ntype TestHandlerProps = {\n  // this ref is populated only in tests\n  testHandlersRef?: TestHandlersRef;\n};\n\ntype DefaultProps = Omit<FilePickerProps, 'isDisabled' | 'children'> & TestHandlerProps;\n\n/**\n * The default file picker element.\n */\nconst DefaultFilePicker = (props: DefaultProps) => {\n  const [validity, setValidity] = useState<'NA' | 'valid' | 'invalid'>('NA');\n\n  // class added to change bg/border color based on if file is valid on drag and drop\n  const validityClass =\n    validity === 'valid' ? 'oj-c-valid-drop' : validity === 'invalid' ? 'oj-c-invalid-drop' : '';\n  const rootRef = useRef<HTMLDivElement>(null);\n\n  const { validation, dragAndDropProps, pressProps, isHover, hoverProps } =\n    useFilepickerElementHelper(props, rootRef, setValidity);\n  const mergedEventProps = mergeProps(pressProps, hoverProps);\n\n  // These are backdoor handles that are used for testing purposes only\n  useSetupTestRef(dragAndDropProps, validation, props.testHandlersRef || null);\n  const classes = classNames([\n    styles.base,\n    props.width === undefined && styles.maxWidth,\n    isHover && styles.hover\n  ]);\n  const { isTabbable } = useTabbableMode();\n  const {\n    accessibleLabel,\n    primaryText,\n    secondaryText,\n    translations,\n    selectionMode,\n    width,\n    height\n  } = props;\n  return (\n    <div\n      {...mergedEventProps}\n      class={classes}\n      tabIndex={isTabbable ? 0 : -1}\n      role=\"button\"\n      aria-label={getAriaLabel({\n        accessibleLabel,\n        isDisabled: false,\n        translations,\n        primaryText,\n        secondaryText,\n        selectionMode\n      })}\n      ref={rootRef}\n      style={getStyles(width, height)}>\n      <div class={classNames([styles.inner, validityClass])} {...dragAndDropProps}>\n        {getDefaultTriggerContent(false, primaryText, secondaryText, translations, selectionMode)}\n      </div>\n    </div>\n  );\n};\n\ntype DisabledProps = Omit<\n  FilePickerProps,\n  'accept' | 'capture' | 'onCommit' | 'onReject' | 'isDisabled'\n>;\n\nconst childrenContainer = (children: ComponentChildren) => {\n  return <div className={childrenStyles}>{children}</div>;\n};\n\n/**\n * The disabled file picker element.\n */\nconst DisabledFilePicker = ({\n  children,\n  accessibleLabel,\n  primaryText,\n  secondaryText,\n  translations,\n  selectionMode,\n  width,\n  height\n}: DisabledProps) => {\n  return (\n    <div\n      class={classNames([\n        styles.base,\n        styles.inner,\n        width === undefined && styles.maxWidth,\n        'oj-c-filepicker-disabled'\n      ])}\n      role=\"button\"\n      aria-label={getAriaLabel({\n        accessibleLabel,\n        isDisabled: true,\n        translations,\n        primaryText,\n        secondaryText\n      })}\n      aria-hidden=\"true\"\n      style={getStyles(width, height)}>\n      {(children && childrenContainer(children)) ||\n        getDefaultTriggerContent(true, primaryText, secondaryText, translations, selectionMode)}\n    </div>\n  );\n};\n\ntype CustomProps = Omit<FilePickerProps, 'isDisabled' | 'primaryText' | 'secondaryText'> &\n  TestHandlerProps;\n\n/**\n * The custom file picker element.\n */\nconst CustomFilePicker = (props: CustomProps) => {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const { validation, dragAndDropProps, pressProps, isHover, hoverProps } =\n    useFilepickerElementHelper(props, rootRef);\n  const mergedEventProps = mergeProps(pressProps, dragAndDropProps, hoverProps);\n\n  // These are backdoor handles that are used for testing purposes only\n  useSetupTestRef(dragAndDropProps, validation, props.testHandlersRef || null);\n\n  const classes = classNames([\n    styles.base,\n    props.width === undefined && styles.maxWidth,\n    isHover && styles.hover\n  ]);\n  const { accessibleLabel, translations, selectionMode } = props;\n  const { isTabbable } = useTabbableMode();\n  return (\n    <div\n      class={classes}\n      tabIndex={isTabbable ? undefined : -1}\n      role=\"button\"\n      aria-label={getAriaLabel({ accessibleLabel, isDisabled: false, translations, selectionMode })}\n      ref={rootRef}\n      style={getStyles(props.width, props.height)}\n      {...mergedEventProps}>\n      {props.children && childrenContainer(props.children)}\n    </div>\n  );\n};\n\n/**\n * Only called for testing purposes, sets up the test ref that\n * allows for backdoor access to certain methods\n */\nconst useSetupTestRef = (\n  dragAndDropProps: DndProps,\n  validation: (files: FileList) => void,\n  testHandlersRef: TestHandlersRef\n) => {\n  useImperativeHandle(testHandlersRef, () => ({\n    onDragEnter: dragAndDropProps.onDragEnter,\n    onDragOver: dragAndDropProps.onDragOver,\n    onDrop: dragAndDropProps.onDrop,\n    onDragLeave: dragAndDropProps.onDragLeave,\n    onClickSelected: validation\n  }));\n};\n\nconst styles = {\n  base: cssProps`${{\n    display: 'block',\n    height: '100%',\n    width: '100%'\n  }}`,\n  maxWidth: cssProps`${{\n    maxWidth: '400px'\n  }}`,\n  inner: cssProps`${{\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    boxSizing: 'border-box',\n    borderRadius: 'var(--oj-c-PRIVATE-DO-NOT-USE-file-picker-border-radius)',\n    paddingTop: 'var(--oj-c-PRIVATE-DO-NOT-USE-file-picker-padding)',\n    paddingRight: 'var(--oj-c-PRIVATE-DO-NOT-USE-file-picker-padding)',\n    paddingLeft: 'var(--oj-c-PRIVATE-DO-NOT-USE-file-picker-padding)',\n    paddingBottom: 'var(--oj-c-PRIVATE-DO-NOT-USE-file-picker-padding)',\n    height: '100%',\n    borderStyle: 'dashed',\n    borderWidth: 'var(--oj-c-PRIVATE-DO-NOT-USE-file-picker-border-width)',\n    backgroundColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-file-picker-bg-color)',\n    borderColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-file-picker-border-color)',\n    '&:active': { backgroundColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-bg-color-active)' }\n  }}`,\n  hover: cssProps`${{\n    // @ts-ignore\n    '&:not(:active)': {\n      cursor: 'var(--oj-c-PRIVATE-DO-NOT-USE-file-picker-cursor)'\n    }\n  }}`,\n\n  pseudohover: cssProps`${{\n    // @ts-ignore\n    '@media(hover: hover)': {\n      '&:hover:enabled:not(:active)': {\n        cursor: 'var(--oj-c-PRIVATE-DO-NOT-USE-file-picker-cursor)'\n      }\n    }\n  }}`\n};\nconst childrenStyles = cssProps`${{\n  /* @ts-ignore */\n  '& > *': {\n    marginTop: '0 !important',\n    marginBottom: '0 !important',\n    marginLeft: '0 !important',\n    marginRight: '0 !important'\n  }\n}}`;\n"],"names":["getDefaultTriggerContent","isDisabled","primaryText","secondaryText","translations","selectionMode","_jsx","Text","Object","assign","variant","weight","size","children","getPrimaryText","Spacer","height","jsx","getSecondaryText","getAriaLabel","accessibleLabel","filePicker_addFiles","getStyles","width","sizeToCSS","undefined","filePicker_dropzonePrimaryText","defaultSecondaryText","filePicker_dropzoneSecondaryTextMultiple","filePicker_dropzoneSecondaryText","validateTypes","files","accept","accepted","rejected","file","type","i","length","name","filePicker_unknownFileTypeUploadError","nameSplit","split","pop","indexOf","_acceptFile","push","createFileList","origList","descriptor","value","item","index","this","enumerable","create","FileList","prototype","validateSelectionMode","getMimeTypeValidationMessages","messages","severity","summary","filePicker_singleTypeUploadError","fileType","filePicker_multipleFileTypeUploadError","fileTypes","join","plural_separator","acceptProp","fileAccept","trim","startsWith","toLowerCase","endsWith","fireRejectAction","isDrag","onReject","resolver","dragPromise","Promise","resolve","until","handleFilesAdded","onCommit","list","useFilepickerElementHelper","props","rootRef","setValidity","callback","validation","clickCallbackUtils","pressProps","usePress","dragAndDropProps","useDragAndDropEvents","hoverProps","isHover","useHover","_handleClickValidation","event","code","preventDefault","pickFiles","_a","capture","_b","inDropZone","useRef","isDroppable","dragPromiseResolver","_handleDragLeave","mimeTypeDropFail","current","stopPropagation","contains","relatedTarget","call","onDragEnter","onDragOver","browser","getClientHints","dataTransfer","items","selectionModeValid","droppable","filePicker_singleFileUploadError","onDragLeave","onDrop","DefaultFilePicker","styles","base","maxWidth","isTabbable","useTabbableMode","childrenContainer","className","childrenStyles","DisabledFilePicker","class","classNames","inner","role","style","CustomFilePicker","classes","tabIndex","ref","mergedEventProps","useSetupTestRef","testHandlersRef","useImperativeHandle","onClickSelected","otherProps","__rest","__testHandlerSymbol","useTranslationBundle"],"mappings":"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"}