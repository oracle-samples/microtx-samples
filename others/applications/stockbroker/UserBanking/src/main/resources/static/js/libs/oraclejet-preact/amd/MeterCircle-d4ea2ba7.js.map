{"version":3,"file":"MeterCircle-d4ea2ba7.js","sources":["../../src/UNSAFE_MeterCircle/CircularReferenceLine.tsx","../../src/UNSAFE_MeterCircle/CircleMeterUtils.ts","../../src/UNSAFE_MeterCircle/LayoutUtils.ts","../../src/UNSAFE_MeterCircle/MeterCircle.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { cssProps } from '@oracle/oraclejet-cssprops';\nimport { getCenterCoord } from '../utils/PRIVATE_meterUtils';\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\ntype getCenterCoordParamType = Parameters<typeof getCenterCoord>;\n\nexport type CircularReferenceLineProps = {\n  color?: ColorProps['color'];\n  angle: number;\n  radius: string;\n  length: string;\n  section: getCenterCoordParamType[0];\n};\n\nexport function CircularReferenceLine({\n  color,\n  angle,\n  radius,\n  length,\n  section = 'full'\n}: CircularReferenceLineProps) {\n  const centerCoord = getCenterCoord(section);\n  const yOffset = `calc(${centerCoord.y * 100}% - ((${Math.sin(\n    (angle * 2 * Math.PI) / 360\n  )} * ${radius})))`;\n  const xOffset = `calc(${centerCoord.x * 100}%  + ((${Math.cos(\n    (angle * 2 * Math.PI) / 360\n  )} * ${radius})))`;\n\n  return (\n    <div\n      class={referenceLineStyles.base}\n      style={{\n        left: xOffset,\n        top: yOffset,\n        width: `calc(${length})`,\n        transform: `translate(0, -1px) rotate(${360 - angle}deg)`,\n        backgroundColor: color\n          ? color\n          : 'var(--oj-c-PRIVATE-DO-NOT-USE-dvt-reference-object-line-color)',\n        borderBottom: '1px solid var(--oj-c-PRIVATE-DO-NOT-USE-dvt-contrast-line-color)'\n      }}></div>\n  );\n}\n\nconst referenceLineStyles = {\n  base: cssProps`${{\n    height: '2px',\n    position: 'absolute',\n    transformOrigin: '0 50%',\n    backgroundClip: 'padding-box'\n  }}`\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { Ref } from 'preact/hooks';\nimport {\n  getPositiveAngle,\n  convertToPolar,\n  getCenterCoord,\n  Sector\n} from '../utils/PRIVATE_meterUtils';\n\nimport { CenterContext } from './MeterCircle.types';\n\ntype Dimensions = {\n  width: number;\n  height: number;\n  innerRadius: number;\n  outerRadius: number;\n};\n\n/**\n * Returns the true dimensions of the meter circle after initial render. All dimensions are 0 for initial render.\n * @param element The HTML element that wraps the track and indicator div.\n * @param section The section in which the meter circle lies.\n * @returns The dimensions of the meter circle.\n */\nexport function getDimensions(element: HTMLElement | null, section: Sector): Dimensions {\n  if (!element) {\n    return {\n      width: 0,\n      height: 0,\n      innerRadius: 0,\n      outerRadius: 0\n    };\n  }\n\n  const circleTrack = element.children[0] as HTMLElement;\n  const rect = circleTrack.getBoundingClientRect();\n\n  return {\n    width: Math.round(rect.width),\n    height: Math.round(rect.height),\n    ...getInnerAndOuterRadius(circleTrack, rect, section)\n  };\n}\n\n/**\n * Returns the inner and outer radius of the meter circle.\n * @param element The HTML element that wraps the track and indicator div.\n * @param rect The bounding rect of the wrapper HTML element.\n * @param section The section in which the meter circle lies.\n * @returns The inner and outer radius of the meter circle.\n */\nfunction getInnerAndOuterRadius(\n  element: HTMLElement,\n  rect: any,\n  section: string\n): {\n  innerRadius: number;\n  outerRadius: number;\n} {\n  const width = element.clientWidth;\n  const height = element.clientHeight;\n\n  if (section === 'bottom' || section === 'top') {\n    return { outerRadius: rect.width / 2, innerRadius: height };\n  } else if (section === 'left' || section === 'right') {\n    return { outerRadius: rect.height / 2, innerRadius: width };\n  }\n  return { innerRadius: width / 2, outerRadius: rect.width / 2 };\n}\n\n/**\n * Returns the value corresponding to clicked point in the meter circle. Returns undefined if the clicked point is\n * outside the track of the meter circle.\n * @param pageX The pageX of the click event\n * @param pageY The pageY of the click event\n * @param max The max value of the meter circle.\n * @param min The min value of the meter circle.\n * @param step The step of the metercircle.\n * @param dimensionsRef The ref that stores dimensions reference of meter circle.\n * @param startAngle The startAngle of the meter circle.\n * @param angleExtent The angleExtent of the meter circle\n * @returns {number} The value corresponding to clicked point in the meter circle.\n */\nexport function getValue(\n  event: PointerEvent,\n  min: number,\n  max: number,\n  step: number,\n  dimensionsRef: Ref<Dimensions>,\n  startAngle: number,\n  angleExtent: number,\n  section: Sector,\n  isRtl: boolean\n): number | undefined {\n  const dims = dimensionsRef.current;\n  if (!dims) {\n    return undefined;\n  }\n\n  const center = getCenterCoord(section);\n  const { angle } = convertToPolar(\n    dims.width * center.x,\n    dims.height * center.y,\n    event.offsetX,\n    event.offsetY\n  );\n\n  const positiveAngle = getPositiveAngle(angle);\n\n  let val;\n  if (isRtl && startAngle + angleExtent > positiveAngle) {\n    val = (getPositiveAngle(angle - startAngle) / angleExtent) * (max - min);\n  }\n\n  if (!isRtl) {\n    const clockwiseArc = getPositiveAngle(startAngle - positiveAngle);\n    if (clockwiseArc <= angleExtent) {\n      val = (clockwiseArc * (max - min)) / angleExtent;\n    }\n  }\n\n  if (val != undefined) {\n    val = Math.round(val / step) * step;\n  }\n  return val;\n}\n\n/**\n * Returns the fraction of angle extent for given delta.\n * @param delta The delta of metric values.\n * @param min The minimum value of the meter circle.\n * @param max The maximum value of the meter circle.\n * @param angleExtent The angle extent of the meter circle.\n * @returns The angle extent corresponding to delta in metric value.\n */\nexport function getAngleExtentFromDelta(\n  delta: number,\n  min: number,\n  max: number,\n  angleExtent: number\n): number {\n  return (delta * angleExtent) / (max - min);\n}\n\n/**\n * Returns the start angle for given metric value.\n * @param value The metric value\n * @param min The minimum value of the meter circle.\n * @param max The maximum value of the meter circle.\n * @param startAngle The startAngle of the meter circle.\n * @param angleExtent The angleExtent of the meter circle.\n * @param isRtl Whether the reading mode is 'rtl'\n * @returns The startAngle for the metric value.\n */\nexport function getStartAngleForValue(\n  value: number,\n  min: number,\n  max: number,\n  startAngle: number,\n  angleExtent: number,\n  isRtl: boolean\n): number {\n  const extent = getAngleExtentFromDelta(value - min, min, max, angleExtent);\n  return startAngle + (isRtl ? 1 : -1) * extent;\n}\n\n/**\n * Returns the center context of for the meter circle.\n */\nexport function getCenterContext(\n  dimensionsRef: Ref<Dimensions>,\n  section: 'top' | 'bottom' | 'left' | 'right' | 'full'\n): CenterContext | undefined {\n  const dims = dimensionsRef.current;\n\n  if (!dims) {\n    return;\n  }\n\n  const center = getCenterCoord(section);\n  const cx = center.x * dims.width;\n  const cy = center.y * dims.height;\n\n  const isHoriz = section === 'top' || section === 'bottom';\n\n  let innerX, innerY, innerW, innerH;\n  let outerX, outerY, outerW, outerH;\n\n  if (isHoriz || section === 'full') {\n    outerW = 2 * dims.innerRadius;\n    outerH = section === 'full' ? 2 * dims.innerRadius : dims.innerRadius;\n    outerX = cx - dims.innerRadius;\n    outerY = section === 'bottom' ? 0 : cy - dims.innerRadius;\n\n    innerW = Math.sqrt(2) * dims.innerRadius;\n    innerH = section === 'full' ? innerW : dims.innerRadius / Math.sqrt(2);\n    innerX = cx - dims.innerRadius / Math.sqrt(2);\n    innerY = section === 'bottom' ? 0 : cy - dims.innerRadius / Math.sqrt(2);\n  } else {\n    outerH = 2 * dims.innerRadius;\n    outerW = dims.innerRadius;\n    outerX = section === 'left' ? cx - dims.innerRadius : 0;\n    outerY = cy - dims.innerRadius;\n\n    innerH = Math.sqrt(2) * dims.innerRadius;\n    innerW = dims.innerRadius / Math.sqrt(2);\n    innerX = section === 'left' ? cx - dims.innerRadius / Math.sqrt(2) : 0;\n    innerY = cy - dims.innerRadius / Math.sqrt(2);\n  }\n\n  return {\n    outerBounds: {\n      x: outerX,\n      y: outerY,\n      width: outerW,\n      height: outerH\n    },\n    innerBounds: {\n      x: innerX,\n      y: innerY,\n      width: innerW,\n      height: innerH\n    }\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Threshold, MeterSize, ThresholdDisplay } from '../utils/UNSAFE_meterTypes';\nimport { getClipPath, Sector } from '../utils/PRIVATE_meterUtils';\nimport { getAngleExtentFromDelta, getStartAngleForValue } from './CircleMeterUtils';\nimport { MeterProps, CircularRefLine } from './MeterCircle.types';\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\n\nexport type MeterInfo = Required<\n  Pick<MeterProps, 'min' | 'max' | 'value' | 'size' | 'startAngle' | 'angleExtent'>\n> & {\n  section: Sector;\n  isRtl: boolean;\n  innerRadius: number;\n};\n\n/**\n * Returns the css variable corresponding to the default size of the meter circle.\n * @param size The size of the meter circle.\n * @returns The css variable corresponding to the default size of the meter circle.\n */\nfunction getSizeVar(size: MeterSize): string {\n  return `var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-${size}-size)`;\n}\n\n/**\n * Returns the css variable corresponding to the default track size of the meter circle.\n * @param size The size of the meter circle.\n * @returns The css variable corresponding to the default track size of the meter circle.\n */\nfunction getTrackSizeVar(size: MeterSize): string {\n  return `var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-${size}-track-size)`;\n}\n\n/**\n * Returns the calculated css variable string for the inner radius when given size and innerRadius of meter circle.\n * @param size The size of the meter circle.\n * @param innerRadius The inner radius of the meter circle.\n * @returns {string} CSS varible string for the calculated inner radius of the meter circle.\n */\n\nexport function getInnerRadius(size: MeterSize, innerRadius?: number): string {\n  if (innerRadius != undefined) {\n    return `(${getSizeVar(size)} * ${innerRadius / 2})`;\n  }\n  return `(${getSizeVar(size)} * 0.5 - ${getTrackSizeVar(size)})`;\n}\n\n/**\n * Returns the calculated css variable string for meter circle track for a given size and innerRadius of meter circle.\n * @param size The size of the meter circle.\n * @param innerRadius The inner radius of the meter circle.\n * @returns {string} CSS variable for the calculated track size of the meter circle.\n */\nexport function getTrackSize(size: MeterSize, innerRadius?: number): string {\n  if (innerRadius != undefined) {\n    return `(${getSizeVar(size)} * ${1 - innerRadius} / 2)`;\n  }\n  return getTrackSizeVar(size);\n}\n\n/**\n * Returns the calculated length of reference line for given size and inner radius of meter circle.\n * The length of reference line runs from the inner radius to slight outside the outer radius.\n * The length outside the outer radius depends on size of the meter circle.\n * @param size The size of the meter circle.\n * @param innerRadius The inner radius of the meter circle.\n * @returns The calculated CSS var for the length of reference line.\n */\nexport function getRefLineLength(size: MeterSize, innerRadius?: number): string {\n  const outerExtent = { sm: '1rem', md: '0.75rem', lg: '0.5rem' };\n  return `${getTrackSize(size, innerRadius)} + ${outerExtent[size]}`;\n}\n\n/**\n * Returns the array of calculated props for InnerCircle representing each threshold.\n * @param meterInfo MeterInfo object containing info about given meter circle.\n * @param thresholds thresholds array of the meter circle.\n * @param isTrackRendered Whether track is rendered.\n * @param trackColor The track color of the meter circle.\n * @param innerRadius The inner radius of the meter circle.\n * @returns Array of calculated props object for InnerCircle representing each threshold.\n */\nexport function getThresholdsProps(\n  meterInfo: MeterInfo,\n  thresholds: Threshold[],\n  isTrackRendered: boolean,\n  trackColor?: ColorProps['color'],\n  innerRadius?: number\n): Array<{\n  clipPath: string;\n  color?: ColorProps['color'];\n  section: Sector;\n  size: string;\n}> {\n  const {\n    min,\n    max,\n    startAngle,\n    angleExtent,\n    size,\n    section,\n    isRtl,\n    innerRadius: innerDim\n  } = meterInfo;\n  const trackSize = `calc(${getTrackSize(size, innerRadius)})`;\n  const thresholdProps = [];\n  const validThresholds = thresholds\n    .filter((threshold: Threshold) => threshold.max > min && threshold.max <= max)\n    .sort((a, b) => a.max - b.max);\n  const numOfThreshold = validThresholds.length;\n  for (let i = 0; i < numOfThreshold; i++) {\n    const threshold = validThresholds[i];\n    const startValue = i === 0 ? min : validThresholds[i - 1].max;\n    const diff = i === 0 ? threshold.max : threshold.max - validThresholds[i - 1].max;\n\n    let thresholdStart = getStartAngleForValue(\n      startValue,\n      min,\n      max,\n      startAngle,\n      angleExtent,\n      isRtl\n    );\n    let thresholdExtent = getAngleExtentFromDelta(diff, min, max, angleExtent);\n\n    const { startOffset, extentOffset } = getThresholdsBuffer(\n      innerDim,\n      angleExtent,\n      i === 0,\n      threshold.max === max,\n      isRtl\n    );\n    const clipPath = getClipPath(\n      thresholdStart + startOffset,\n      thresholdExtent + extentOffset,\n      isRtl,\n      section\n    );\n    thresholdProps.push({\n      clipPath,\n      color: threshold?.color,\n      size: trackSize,\n      section\n    });\n\n    if (i === numOfThreshold - 1 && threshold.max < max && isTrackRendered) {\n      thresholdStart = thresholdStart + (isRtl ? 1 : -1) * thresholdExtent;\n      thresholdExtent = getAngleExtentFromDelta(max - threshold.max, min, max, angleExtent);\n      const { startOffset, extentOffset } = getThresholdsBuffer(\n        innerDim,\n        angleExtent,\n        false,\n        true,\n        isRtl\n      );\n      thresholdProps.push({\n        clipPath: getClipPath(\n          thresholdStart + startOffset,\n          thresholdExtent + extentOffset,\n          isRtl,\n          section\n        ),\n        color: trackColor,\n        size: trackSize,\n        section\n      });\n    }\n  }\n  return thresholdProps;\n}\n\n/**\n * Returns the calculated props for CircularReferenceLine.\n * @param meterInfo MeterInfo object containing info about the meter circle.\n * @param refLine The CircularRefLine object\n * @param innerRadius The innerRadius of the meter circle.\n * @returns An bject with calculated props for CircularReferenceLine.\n */\nexport function getReferenceLinesProps(\n  meterInfo: MeterInfo,\n  refLine: CircularRefLine,\n  innerRadius?: number\n): {\n  radius: string;\n  length: string;\n  angle: number;\n  color?: ColorProps['color'];\n} {\n  const { min, max, startAngle, angleExtent, size, isRtl } = meterInfo;\n  return {\n    radius: getInnerRadius(size, innerRadius),\n    length: getRefLineLength(size, innerRadius),\n    angle: getStartAngleForValue(refLine.value, min, max, startAngle, angleExtent, isRtl),\n    color: refLine.color\n  };\n}\n\n/**\n * Returns the calculated props for InnerCircle representing the track.\n * @param meterInfo MeterInfo object containing info about the meter circle.\n * @param trackColor The color of the track.\n * @param istrackRendered Whether the track is rendered.\n * @param thresholdDisplay Specifies whether the current threshold is displayed in the track, on the indicator, or if all thresholds are displayed in the track.\n * @param innerRadius The innerRadius of the meter circle.\n * @param thresholds thresholds array of the meter circle.\n * @returns An object with calculated props for InnerCircle that represents the track.\n */\nexport function getTrackProps(\n  meterInfo: MeterInfo,\n  isTrackRendered: boolean,\n  thresholdDisplay: ThresholdDisplay,\n  trackColor?: ColorProps['color'],\n  innerRadius?: number,\n  thresholds?: Threshold[]\n): {\n  section: Sector;\n  color?: ColorProps['color'];\n  clipPath: string;\n  size: string;\n} {\n  const { startAngle, angleExtent, size, section, isRtl } = meterInfo;\n  const color = !isTrackRendered\n    ? 'transparent'\n    : thresholdDisplay === 'all' && thresholds\n    ? 'var(--oj-c-PRIVATE-DO-NOT-USE-dvt-contrast-line-color)'\n    : trackColor;\n  return {\n    section,\n    color,\n    clipPath: getClipPath(startAngle, angleExtent, isRtl, section),\n    size: `calc(${getTrackSize(size, innerRadius)})`\n  };\n}\n\n/**\n * Returns the calculated props for InnerCircle representing the indicator.\n * @param meterInfo MeterInfo object containing info about the meter circle.\n * @param indicatorSize Relative thickness of the indicator to the track.\n * @param innerRadius The innerRadius of the meter circle.\n * @returns An object with calculated props for InnerCircle that represents the indicator.\n */\nexport function getIndicatorProps(\n  meterInfo: MeterInfo,\n  indicatorSize: number,\n  innerRadius?: number\n): {\n  section: Sector;\n  width: string;\n  height: string;\n  size: string;\n  clipPath: string;\n} {\n  const { value, min, max, startAngle, angleExtent, size, section, isRtl } = meterInfo;\n  const valueExtent = ((value - min) * angleExtent) / (max - min);\n  const validIndicatorSize = Math.min(Math.max(0, indicatorSize), 1);\n  const isHoriz = section === 'left' || section === 'right';\n  const isVert = section === 'top' || section === 'bottom';\n  const valueTrackSize = `calc(${getTrackSize(size, innerRadius)} * ${validIndicatorSize})`;\n  const diameter = `${getSizeVar(size)} - ((1 - ${validIndicatorSize}) * ${getTrackSize(\n    size,\n    innerRadius\n  )})`;\n  const radius = `(${diameter}) / 2`;\n  return {\n    section,\n    width: isHoriz ? `calc(${radius})` : `calc(${diameter})`,\n    height: isVert ? `calc(${radius})` : `calc(${diameter})`,\n    size: valueTrackSize,\n    clipPath: getClipPath(startAngle, valueExtent, isRtl, section)\n  };\n}\n\n/**\n * Returns the threshold offsets to create the whitespace between the thresholds.\n * @param innerRadius The innerRadius of the meter circle.\n * @param angleExtent The angleExtent of the meter circle.\n * @param firstThreshold Whether the current threshold is the first threshold.\n * @param lastThreshold  Whether the current threshold is the last threshold.\n * @param isRtl Whether the document reading mode is 'rtl'\n * @returns The offsets (startOffset and extentOffset) to add to calculated threshold startAngle and threhsold extent.\n */\nfunction getThresholdsBuffer(\n  innerRadius: number,\n  angleExtent: number,\n  firstThreshold: boolean,\n  lastThreshold: boolean,\n  isRtl: boolean\n): {\n  startOffset: number;\n  extentOffset: number;\n} {\n  if (!innerRadius) {\n    return { startOffset: 0, extentOffset: 0 };\n  }\n  const offset = 360 / (2 * Math.PI * innerRadius);\n  let startOffset = (offset / 2) * (isRtl ? 1 : -1);\n  let extentOffset = -1 * offset;\n\n  if (firstThreshold && angleExtent < 360) {\n    startOffset = 0;\n    extentOffset = -0.5 * offset;\n  }\n\n  if (lastThreshold && angleExtent < 360) {\n    extentOffset = -0.5 * offset;\n  }\n  return { startOffset, extentOffset };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { cssProps } from '@oracle/oraclejet-cssprops';\nimport { useEffect, useRef, useState } from 'preact/hooks';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { CircleWrapper, CircleInner } from '../PRIVATE_Meter';\nimport { CircularReferenceLine } from './CircularReferenceLine';\n\nimport {\n  validateRange,\n  getTrackAndIndicatorColor,\n  getMeterAriaProps,\n  getCircleSection\n} from '../utils/PRIVATE_meterUtils';\n\nimport { getDimensions, getValue, getCenterContext } from './CircleMeterUtils';\n\nimport {\n  getIndicatorProps,\n  getTrackProps,\n  getThresholdsProps,\n  getReferenceLinesProps,\n  MeterInfo\n} from './LayoutUtils';\n\nimport {\n  usePointerEvents,\n  useKeyboardEvents,\n  useMeterDatatip\n} from '../hooks/PRIVATE_useDvtMeterEvents';\n\nimport { MeterProps, CircularRefLine } from './MeterCircle.types';\nimport { useTabbableMode } from '../hooks/UNSAFE_useTabbableMode';\n\n/**\n * A Meter circle displays information graphically in a circular bar, highlighting a specific metric value's progress in relation to its min, max, or thresholds.\n */\nexport function MeterCircle({\n  max = 100,\n  min = 0,\n  value = 0,\n  step = 1,\n  size = 'lg',\n  startAngle = 90,\n  angleExtent = 360,\n  isTrackRendered = true,\n  thresholdDisplay = 'all',\n  indicatorSize = 1,\n  ...props\n}: MeterProps) {\n  validateRange(min, max, value, step);\n\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n  const section = getCircleSection(startAngle, angleExtent, isRtl);\n  const dimensionsRef = useRef(getDimensions(null, section));\n  const circleWrapperRef = useRef<HTMLDivElement>(null);\n  const [isDimsReady, setDimsReady] = useState<boolean>(false);\n\n  useEffect(() => {\n    if (props.onCommit || props.onInput || props.children) {\n      dimensionsRef.current = getDimensions(circleWrapperRef.current, section);\n      setDimsReady(true);\n    }\n  }, [size, props.onCommit, props.onInput, props.children]);\n\n  const getValueFromEvent = (event: PointerEvent) => {\n    const circleContainer = circleWrapperRef.current;\n    if (event.target == circleContainer) {\n      return getValue(\n        event,\n        min,\n        max,\n        step,\n        dimensionsRef,\n        startAngle,\n        angleExtent,\n        section,\n        isRtl\n      );\n    }\n    return;\n  };\n\n  const pointerEventsProps = usePointerEvents(\n    value,\n    getValueFromEvent,\n    circleWrapperRef,\n    props.onCommit,\n    props.onInput\n  );\n\n  const keyboardEventsProps = useKeyboardEvents(\n    value,\n    min,\n    max,\n    step,\n    props.onCommit,\n    props.onInput\n  );\n\n  const { datatipContent, datatipProps } = useMeterDatatip(\n    value,\n    props.datatip,\n    props.ariaDescribedBy\n  );\n\n  const ariaProps = getMeterAriaProps(\n    value,\n    min,\n    max,\n    `${value}`,\n    props.accessibleLabel,\n    props.ariaLabelledBy,\n    props.thresholds\n  );\n  const mergedProps = mergeProps(pointerEventsProps, keyboardEventsProps, datatipProps, ariaProps);\n\n  const { trackColor, indicatorColor } = getTrackAndIndicatorColor(\n    value,\n    thresholdDisplay,\n    props.trackColor,\n    props.indicatorColor,\n    props.thresholds\n  );\n\n  const orientation =\n    section === 'bottom' || section === 'top'\n      ? 'Horizontal'\n      : section === 'left' || section === 'right'\n      ? 'Vertical'\n      : 'Full';\n\n  const meterInfo = {\n    min,\n    max,\n    value,\n    startAngle,\n    angleExtent,\n    size,\n    section,\n    isRtl,\n    innerRadius: dimensionsRef.current.innerRadius\n  } as MeterInfo;\n  const isInteractive = props.onCommit || props.onInput;\n  const { isTabbable } = useTabbableMode();\n  const centerContext = getCenterContext(dimensionsRef, section);\n  return (\n    <>\n      <div\n        class={classNames([component.base, isInteractive ? component.interactive : ''])}\n        tabIndex={!isTabbable ? -1 : 0}\n        role=\"slider\"\n        {...mergedProps}>\n        <CircleWrapper\n          ref={circleWrapperRef}\n          class={classNames([\n            circleWrapper.base,\n            props.referenceLines && props.referenceLines.length > 0\n              ? styles[`${size}${section}`]\n              : '',\n            styles[`${size}${orientation}`]\n          ])}>\n          <CircleInner\n            class={classNames([circleTrack.base, styles[section]])}\n            {...getTrackProps(\n              meterInfo,\n              isTrackRendered,\n              thresholdDisplay,\n              trackColor,\n              props.innerRadius,\n              props.thresholds\n            )}\n          />\n          {thresholdDisplay === 'all' &&\n            props.thresholds &&\n            getThresholdsProps(\n              meterInfo,\n              props.thresholds,\n              isTrackRendered,\n              trackColor,\n              props.innerRadius\n            ).map((threshold) => {\n              return (\n                <CircleInner\n                  class={classNames([circleTrack.base, styles[section], styles.thresholds])}\n                  {...threshold}\n                />\n              );\n            })}\n\n          <CircleInner\n            color={indicatorColor}\n            class={classNames([circleValue.base, circleValue[section], styles[section]])}\n            {...getIndicatorProps(meterInfo, indicatorSize, props.innerRadius)}\n          />\n          {props.referenceLines?.map((refLine: CircularRefLine) => {\n            return (\n              <CircularReferenceLine\n                {...getReferenceLinesProps(meterInfo, refLine, props.innerRadius)}\n                section={section}\n              />\n            );\n          })}\n          {isDimsReady && props.children && centerContext && (\n            <div class={classNames([styles.centerContent, childrenStyles])}>\n              {props.children(centerContext)}\n            </div>\n          )}\n        </CircleWrapper>\n      </div>\n      {datatipContent}\n    </>\n  );\n}\n\nconst component = {\n  base: cssProps`${{\n    display: 'inline-block',\n    pointerEvents: 'none'\n  }}`,\n  interactive: cssProps`${{\n    touchAction: 'none',\n    '&:focus-visible': {\n      outlineColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-focus-border-color)',\n      outlineStyle: 'dotted',\n      outlineWidth: '1px'\n    }\n  }}`\n};\n\nconst styles = {\n  full: cssProps`${{\n    borderRadius: '50%'\n  }}`,\n  top: cssProps`${{\n    borderRadius: '50% 50% 0 0 / 100% 100% 0 0',\n    borderBottom: '0'\n  }}`,\n  bottom: cssProps`${{\n    borderRadius: '0% 0% 50% 50% / 0% 0% 100% 100%',\n    borderTop: '0'\n  }}`,\n  right: cssProps`${{\n    borderRadius: '0 100% 100% 0 / 0% 50% 50% 0%',\n    borderLeft: '0'\n  }}`,\n  left: cssProps`${{\n    borderRadius: '100% 0 0 100% / 50% 0 0 50%',\n    borderRight: '0'\n  }}`,\n  smtop: cssProps`${{\n    margin: '1rem 1rem 0 1rem'\n  }}`,\n  mdtop: cssProps`${{\n    margin: '0.75rem 0.75rem 0 0.75rem'\n  }}`,\n  lgtop: cssProps`${{\n    margin: '0.5rem 0.5rem 0 0.5rem'\n  }}`,\n  smbottom: cssProps`${{\n    margin: '0 1rem 1rem 1rem'\n  }}`,\n  mdbottom: cssProps`${{\n    margin: '0 0.75rem 0.75rem 0.75rem'\n  }}`,\n  lgbottom: cssProps`${{\n    margin: '0 0.5rem 0.5rem 0.5rem'\n  }}`,\n  smleft: cssProps`${{\n    margin: '1rem 0 1rem 1rem'\n  }}`,\n  mdleft: cssProps`${{\n    margin: '0.75rem 0 0.75rem 0.75rem'\n  }}`,\n  lgleft: cssProps`${{\n    margin: '0.5rem 0 0.5rem 0.5rem'\n  }}`,\n  smright: cssProps`${{\n    margin: '1rem 1rem 1rem 0'\n  }}`,\n  mdright: cssProps`${{\n    margin: '0.75rem 0.75rem 0.75rem 0'\n  }}`,\n  lgright: cssProps`${{\n    margin: '0.5rem 0.5rem 0.5rem 0'\n  }}`,\n  smfull: cssProps`${{\n    margin: '1rem'\n  }}`,\n  mdfull: cssProps`${{\n    margin: '0.75rem'\n  }}`,\n  lgfull: cssProps`${{\n    margin: '0.5rem'\n  }}`,\n  lgHorizontal: cssProps`${{\n    height: 'calc(var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-lg-size) / 2 )',\n    width: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-lg-size)'\n  }}`,\n  lgVertical: cssProps`${{\n    width: 'calc(var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-lg-size) / 2 )',\n    height: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-lg-size)'\n  }}`,\n  smHorizontal: cssProps`${{\n    height: 'calc(var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-sm-size) / 2 )',\n    width: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-sm-size)'\n  }}`,\n  smVertical: cssProps`${{\n    width: 'calc(var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-sm-size) / 2 )',\n    height: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-sm-size)'\n  }}`,\n  mdHorizontal: cssProps`${{\n    height: 'calc(var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-md-size) / 2 )',\n    width: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-md-size)'\n  }}`,\n  mdVertical: cssProps`${{\n    width: 'calc(var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-md-size) / 2 )',\n    height: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-md-size)'\n  }}`,\n  smFull: cssProps`${{\n    width: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-sm-size)',\n    height: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-sm-size)'\n  }}`,\n  mdFull: cssProps`${{\n    width: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-md-size)',\n    height: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-md-size)'\n  }}`,\n  lgFull: cssProps`${{\n    width: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-lg-size)',\n    height: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-circle-lg-size)'\n  }}`,\n  centerContent: cssProps`${{\n    pointerEvents: 'none',\n    width: '100%',\n    height: '100%',\n    lineHeight: 'initial'\n  }}`,\n  thresholds: cssProps`${{\n    borderColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-threshold-color)'\n  }}`\n};\nconst childrenStyles = cssProps`${{\n  /* @ts-ignore */\n  '& > *': {\n    marginTop: '0 !important',\n    marginBottom: '0 !important',\n    marginLeft: '0 !important',\n    marginRight: '0 !important'\n  }\n}}`;\n\nconst circleWrapper = {\n  base: cssProps`${{\n    position: 'relative',\n    boxSizing: 'border-box',\n    cursor: 'pointer',\n    pointerEvents: 'auto'\n  }}`\n};\n\nconst circleTrack = {\n  base: cssProps`${{\n    width: '100%',\n    height: '100%',\n    position: 'absolute',\n    borderStyle: 'solid',\n    boxSizing: 'border-box',\n    pointerEvents: 'none',\n    borderColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-track-bg-color)'\n  }}`,\n  sm: cssProps`${{\n    borderWidth: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-sm-track-size)'\n  }}`,\n  md: cssProps`${{\n    borderWidth: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-md-track-size)'\n  }}`,\n  lg: cssProps`${{\n    borderWidth: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-lg-track-size)'\n  }}`\n};\n\nconst circleValue = {\n  base: cssProps`${{\n    borderColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-value-bg-color)',\n    borderStyle: 'solid',\n    boxSizing: 'border-box',\n    position: 'absolute',\n    pointerEvents: 'none'\n  }}`,\n  full: cssProps`${{\n    borderRadius: '50%',\n    top: '50%',\n    left: '50%',\n    translate: '-50% -50%'\n  }}`,\n  top: cssProps`${{\n    top: '100%',\n    left: '50%',\n    translate: '-50% -100%'\n  }}`,\n  right: cssProps`${{\n    top: '50%',\n    translate: '0 -50%'\n  }}`,\n  left: cssProps`${{\n    left: '100%',\n    top: '50%',\n    translate: '-100% -50%'\n  }}`,\n  bottom: cssProps`${{\n    left: '50%',\n    translate: '-50% 0'\n  }}`\n};\n"],"names":["CircularReferenceLine","color","angle","radius","length","section","centerCoord","getCenterCoord","yOffset","y","Math","sin","PI","xOffset","x","cos","left","top","transform","backgroundColor","borderBottom","referenceLineStyles","getDimensions","element","width","height","innerRadius","outerRadius","circleTrack","children","rect","getBoundingClientRect","Object","assign","round","clientWidth","clientHeight","getInnerAndOuterRadius","getAngleExtentFromDelta","delta","min","max","angleExtent","getStartAngleForValue","value","startAngle","isRtl","getSizeVar","size","getTrackSizeVar","getInnerRadius","undefined","getTrackSize","getRefLineLength","sm","md","lg","getThresholdsProps","meterInfo","thresholds","isTrackRendered","trackColor","innerDim","trackSize","thresholdProps","validThresholds","filter","threshold","sort","a","b","numOfThreshold","i","startValue","diff","thresholdStart","thresholdExtent","startOffset","extentOffset","getThresholdsBuffer","clipPath","getClipPath","push","getTrackProps","thresholdDisplay","getIndicatorProps","indicatorSize","valueExtent","validIndicatorSize","isHoriz","isVert","valueTrackSize","diameter","firstThreshold","lastThreshold","offset","component","styles","childrenStyles","circleWrapper","circleValue","_a","direction","useUser","circleWrapperRef","useRef","props","onCommit","onInput","pointerEventsProps","usePointerEvents","event","circleContainer","current","target","step","dimensionsRef","dims","center","convertToPolar","offsetX","offsetY","positiveAngle","getPositiveAngle","val","clockwiseArc","datatipContent","datatipProps","useMeterDatatip","datatip","ariaDescribedBy","mergedProps","mergeProps","keyboardEventsProps","ariaProps","isTabbable","useTabbableMode","cx","cy","innerX","innerY","innerW","innerH","outerX","outerY","outerW","outerH","sqrt","outerBounds","innerBounds","base","orientation","_jsx","jsx","CircleInner","class","classNames","refLine","isDimsReady","centerContext","centerContent"],"mappings":"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"}