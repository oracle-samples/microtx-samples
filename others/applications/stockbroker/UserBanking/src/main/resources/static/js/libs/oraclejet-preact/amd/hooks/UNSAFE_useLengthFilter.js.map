{"version":3,"file":"UNSAFE_useLengthFilter.js","sources":["../../../src/hooks/UNSAFE_useLengthFilter/useLengthFilter.ts"],"sourcesContent":["import { ComponentProps } from 'preact';\nimport { useCallback, useEffect, useState } from 'preact/hooks';\nimport { TextFieldInput } from '../../UNSAFE_TextField';\nimport { calcLength, CountUnit as _CountUnit, filter } from '../../utils/UNSAFE_lengthFilter';\n\nexport type CountUnit = _CountUnit;\n\ntype PickedPropsFromTextFieldInput = Pick<\n  ComponentProps<typeof TextFieldInput>,\n  'onCommit' | 'onInput' | 'value'\n>;\ntype UseLengthFilterProps = PickedPropsFromTextFieldInput & {\n  maxLength?: number;\n  maxLengthUnit?: CountUnit;\n};\n\n/**\n * A custom hook that applies the length filter to text field input\n * @param param0 The props for the useLengthFilter hook\n * @returns The filtered event handlers\n */\nexport function useLengthFilter({\n  maxLength,\n  maxLengthUnit,\n  onCommit,\n  onInput,\n  value\n}: UseLengthFilterProps) {\n  const [isMaxLengthExceeded, setMaxLengthExceeded] = useState(false);\n  const parse = useCallback(\n    (value: string) => filter(value, maxLength, maxLengthUnit),\n    [maxLength, maxLengthUnit]\n  );\n  // Reapply maxLength filter when the value is changed\n  useEffect(() => {\n    if (value === undefined) {\n      return;\n    }\n\n    const filteredValue = parse(value);\n    if (filteredValue !== value) {\n      onInput?.({ previousValue: value, value: filteredValue });\n      onCommit?.({ previousValue: value, value: filteredValue });\n\n      // Value is filtered, means that the max length is exceeded\n      setMaxLengthExceeded(true);\n    } else {\n      // Value is not filtered, means that the max length is not exceeded\n      setMaxLengthExceeded(false);\n    }\n  }, [value, onCommit, onInput, parse]);\n\n  const onFilteredInput = useCallback(\n    (...args: Parameters<Exclude<typeof onInput, undefined>>) => {\n      const { previousValue, value } = args[0];\n      const filteredValue = parse(value ?? '');\n\n      // Call the onInput event only when the value is changed\n      if (previousValue !== filteredValue) {\n        onInput?.({ ...args[0], value: filteredValue });\n        // value is not filtered, so the max length is not exceeded\n        setMaxLengthExceeded(false);\n      } else {\n        // value is changed but then filtered to previous value\n        // meaning that the max length was exceeded\n        setMaxLengthExceeded(true);\n      }\n    },\n    [onInput, parse]\n  );\n\n  return {\n    isMaxLengthExceeded,\n    valueLength: value === undefined ? undefined : calcLength(value, maxLengthUnit),\n    onFilteredInput\n  };\n}\n"],"names":["maxLength","maxLengthUnit","onCommit","onInput","value","isMaxLengthExceeded","setMaxLengthExceeded","useState","parse","useCallback","filter","useEffect","undefined","filteredValue","previousValue","onFilteredInput","args","valueLength","calcLength"],"mappings":"gHAqBgB,UAAgBA,UAC9BA,EAD8BC,cAE9BA,EAF8BC,SAG9BA,EAH8BC,QAI9BA,EAJ8BC,MAK9BA,IAEA,MAAOC,EAAqBC,GAAwBC,EAAQA,UAAC,GACvDC,EAAQC,EAAAA,YACXL,GAAkBM,EAAAA,OAAON,EAAOJ,EAAWC,GAC5C,CAACD,EAAWC,IAGdU,EAAAA,UAAU,KACR,QAAcC,IAAVR,EACF,OAGF,MAAMS,EAAgBL,EAAMJ,GACxBS,IAAkBT,GACpBD,MAAAA,GAAAA,EAAU,CAAEW,cAAeV,EAAOA,MAAOS,IACzCX,MAAAA,GAAAA,EAAW,CAAEY,cAAeV,EAAOA,MAAOS,IAG1CP,GAAqB,IAGrBA,GAAqB,IAEtB,CAACF,EAAOF,EAAUC,EAASK,IAE9B,MAAMO,EAAkBN,EAAAA,YACtB,IAAIO,KACF,MAAMF,cAAEA,EAAFV,MAAiBA,GAAUY,EAAK,GAChCH,EAAgBL,EAAMJ,MAAAA,EAAAA,EAAS,IAGjCU,IAAkBD,GACpBV,MAAAA,GAAAA,iCAAea,EAAK,IAAI,CAAAZ,MAAOS,KAE/BP,GAAqB,IAIrBA,GAAqB,IAGzB,CAACH,EAASK,IAGZ,MAAO,CACLH,oBAAAA,EACAY,iBAAuBL,IAAVR,OAAsBQ,EAAYM,EAAUA,WAACd,EAAOH,GACjEc,gBAAAA"}