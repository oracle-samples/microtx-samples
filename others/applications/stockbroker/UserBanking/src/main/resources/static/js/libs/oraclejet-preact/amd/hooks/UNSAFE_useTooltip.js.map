{"version":3,"file":"UNSAFE_useTooltip.js","sources":["../../../src/hooks/UNSAFE_useTooltip/TooltipContent.tsx","../../../src/hooks/UNSAFE_useTooltip/useTooltipControlled.tsx","../../../src/hooks/UNSAFE_useTooltip/useTooltip.tsx"],"sourcesContent":["import { useAnimation } from '../UNSAFE_useAnimation';\nimport { useId } from '../UNSAFE_useId';\nimport { cssProps } from '@oracle/oraclejet-cssprops';\nimport { classNames } from '../../utils/UNSAFE_classNames';\nimport { useEffect, useRef } from 'preact/hooks';\nimport { HTMLAttributesSignalExcluded } from '../../utils/UNSAFE_attributeUtils';\n\ntype IntrinsicProps = Pick<HTMLAttributesSignalExcluded<HTMLDivElement>, 'children'>;\n\ntype Status = 'mounted' | 'unmounted';\n\ntype ContentProps = IntrinsicProps & {\n  isOpen: boolean;\n  isDatatip: boolean;\n  onTransitionEnd: () => void;\n};\n\nconst styles = {\n  wrapper: cssProps`${{\n    display: 'flex',\n    alignItems: 'flex-end',\n    overflowY: 'hidden'\n  }}`,\n  inner: cssProps`${{\n    opacity: '0',\n    maxHeight: '0'\n  }}`,\n  base: cssProps`${{\n    color: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-text-color)',\n    backgroundColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-bg-color)',\n    whiteSpace: 'nowrap',\n    paddingTop: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-padding-vertical)',\n    paddingLeft: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-padding-horizontal)',\n    paddingRight: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-padding-horizontal)',\n    paddingBottom: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-padding-vertical)',\n    borderRadius: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-border-radius)',\n    borderColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-border-color)',\n    fontSize: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-font-size)',\n    borderWidth: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-border-width)',\n    borderStyle: 'solid'\n  }}`,\n  datatip: cssProps`${{\n    '--oj-c-PRIVATE-DO-NOT-USE-tooltip-bg-color':\n      'rgb(var(--oj-c-PRIVATE-DO-NOT-USE-palette-neutral-rgb-0))',\n    '--oj-c-PRIVATE-DO-NOT-USE-tooltip-text-color':\n      'rgb(var(--oj-c-PRIVATE-DO-NOT-USE-palette-neutral-rgb-190))',\n    '--oj-c-PRIVATE-DO-NOT-USE-tooltip-padding-vertical':\n      'var(--oj-c-PRIVATE-DO-NOT-USE-core-spacing-2x)',\n    '--oj-c-PRIVATE-DO-NOT-USE-tooltip-border-radius':\n      'var(--oj-c-PRIVATE-DO-NOT-USE-core-border-radius-md)',\n    '--oj-c-PRIVATE-DO-NOT-USE-tooltip-border-color':\n      'rgba(var(--oj-c-PRIVATE-DO-NOT-USE-palette-neutral-rgb-190), 0.65)',\n    '--oj-c-PRIVATE-DO-NOT-USE-tooltip-font-size':\n      'var(--oj-c-PRIVATE-DO-NOT-USE-typography-body-xs-font-size)'\n  }}`\n};\n\nexport const TooltipContent = ({\n  children,\n  isOpen,\n  isDatatip,\n  onTransitionEnd,\n  ...props\n}: ContentProps) => {\n  const uniqueID = useId();\n  const wrapperRef = useRef<HTMLDivElement>(null);\n  const popoverRef = useRef<HTMLDivElement>(null);\n\n  const { nodeRef } = useAnimation<Status, HTMLDivElement>(isOpen ? 'mounted' : 'unmounted', {\n    animationStates: {\n      mounted: (_node) => {\n        const childNode = _node.firstChild as HTMLDivElement;\n        return {\n          from: {\n            maxHeight: '0',\n            opacity: '0%'\n          },\n          to: {\n            maxHeight: `${childNode?.offsetHeight}px`,\n            opacity: isDatatip ? '100%' : '95%'\n          },\n          options: {\n            duration: isDatatip ? 1 : 100,\n            easing: [0.0, 0.0, 0.2, 1]\n          }\n        };\n      },\n      unmounted: (_node) => {\n        return {\n          from: {\n            opacity: isDatatip ? '100%' : '95%'\n          },\n          to: {\n            maxHeight: '0',\n            opacity: '0%'\n          },\n          options: {\n            duration: isDatatip ? 1 : 100,\n            easing: [0.0, 0.0, 0.2, 1]\n          }\n        };\n      }\n    },\n    isAnimatedOnMount: true,\n    onAnimationEnd: () => onTransitionEnd?.()\n  });\n\n  // Set up initial wrapper height so Tooltip can animate from the bottom to the top\n  useEffect(() => {\n    if (wrapperRef.current && popoverRef.current?.offsetHeight) {\n      wrapperRef.current.style.height = `${popoverRef.current?.offsetHeight}px`;\n    }\n  }, []);\n\n  return (\n    <div ref={wrapperRef} id={uniqueID} role=\"tooltip\" class={styles.wrapper}>\n      <div ref={nodeRef} class={classNames([styles.inner])} {...props}>\n        <div ref={popoverRef} class={classNames([styles.base, isDatatip ? styles.datatip : ''])}>\n          {children}\n        </div>\n      </div>\n    </div>\n  );\n};\n","import { ComponentChild } from 'preact';\nimport { useState, useRef, useEffect, useLayoutEffect, useCallback } from 'preact/hooks';\nimport { useId } from '../UNSAFE_useId';\nimport { Floating, Placement, Coords } from '../../UNSAFE_Floating';\nimport { Layer } from '../../UNSAFE_Layer';\nimport { useHover } from '../UNSAFE_useHover';\nimport { useFocus } from '../UNSAFE_useFocus';\nimport { useTouch } from '../UNSAFE_useTouch';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\nimport { stringLiteralArray } from '../../utils/UNSAFE_arrayUtils';\nimport { TooltipContent } from './TooltipContent';\n\nexport const positions = stringLiteralArray([\n  'start',\n  'top-start',\n  'top',\n  'top-end',\n  'end',\n  'bottom-end',\n  'bottom',\n  'bottom-start'\n]);\ntype Position = typeof positions[number];\n\nconst positionToPlacement = (position: Position) => {\n  let placement: Placement = 'bottom';\n\n  switch (position) {\n    case 'top':\n    case 'end':\n    case 'bottom':\n    case 'start':\n      placement = position as Placement;\n      break;\n\n    case 'top-end':\n      placement = 'top-end-corner';\n      break;\n\n    case 'bottom-end':\n      placement = 'bottom-end-corner';\n      break;\n\n    case 'bottom-start':\n      placement = 'bottom-start-corner';\n      break;\n\n    case 'top-start':\n      placement = 'top-start-corner';\n      break;\n  }\n\n  return placement;\n};\n\nexport const anchorTos = stringLiteralArray(['element', 'pointer']);\ntype AnchorTo = typeof anchorTos[number];\n\ntype AnchorModel = { x: AnchorTo; y: AnchorTo };\n\ntype Props = {\n  text?: string;\n  variant?: 'tooltip' | 'datatip';\n  isOpen: boolean;\n  position?: Position;\n  isDisabled?: boolean;\n  anchor?: AnchorModel;\n  offset?: { mainAxis?: number; crossAxis?: number };\n  onToggle?: (details: { value: boolean }) => void;\n};\n\n/**\n * The 'mounting' and 'unmounting' states are related to the animation. The 'unmounted' state\n * is used for conditional rendering. In this state, the Tooltip content is completely removed\n * from the DOM. The 'mountPending' and 'unmountPending' are used when timeout is active.\n * The 'reposition' state is used to trigger a transition with new coordinates within\n * the same element.\n */\ntype Status =\n  | 'unmounted'\n  | 'mountPending'\n  | 'mounting'\n  | 'mounted'\n  | 'unmountPending'\n  | 'unmounting';\n\nexport const useTooltipControlled = ({\n  text,\n  isOpen = false,\n  variant = 'tooltip',\n  position = 'bottom',\n  isDisabled = false,\n  anchor = { x: 'element', y: 'element' },\n  offset = { mainAxis: 0, crossAxis: 0 },\n  onToggle\n}: Props): {\n  tooltipContent: ComponentChild;\n  tooltipProps: Record<string, any>;\n} => {\n  const disabled = isDisabled || !text;\n  const isInitialRenderState = useRef<boolean>(true);\n  const [state, setState] = useState<Status>(!disabled && isOpen ? 'mounting' : 'unmounted');\n  const [needsUpdate, setNeedsUpdate] = useState<boolean>(false);\n  setNeedsUpdate(false);\n\n  const isDatatip = variant === 'datatip';\n  const isInitialRenderTrigger = useRef<boolean>(true);\n  const { hoverProps, isHover } = useHover({ isDisabled });\n  const { touchProps, isTouch } = useTouch({ isDisabled }); // TODO replace by useLongPress actionhook\n  // we only care about keyboard focus, don't enable useFocus hook if isHover or isTouch are active\n  const { focusProps, isFocus } = useFocus({ isDisabled: isHover || isTouch });\n  const { hoverProps: popoverHoverProps, isHover: popoverIsHover } = useHover({ isDisabled });\n\n  const isPointer = anchor.x === 'pointer' || anchor.y === 'pointer';\n\n  const uniqueID = useId();\n  const targetRef = useRef<HTMLElement | null>(null);\n  const coordsRef = useRef<Coords>({ x: 0, y: 0 });\n  // if anchor is set to pointer and target does not have keyboard focus, use coords\n  const usedRef = isPointer && !isFocus ? coordsRef : targetRef;\n  const delay = isDatatip ? 0 : 250;\n  const toggleTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const updateTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  const toggleTimeoutClear = () => {\n    if (toggleTimeoutRef.current) {\n      clearTimeout(toggleTimeoutRef.current);\n    }\n  };\n\n  const updateTimeoutClear = () => {\n    if (updateTimeoutRef.current) {\n      clearTimeout(updateTimeoutRef.current);\n    }\n  };\n\n  const updateState = useCallback(\n    (open: boolean) => {\n      if (open) {\n        // At least one toggle event is set to true\n        switch (state) {\n          case 'unmounting':\n          case 'unmounted':\n            setState('mountPending'); // Set mount pending state if tooltip is unmounted or in unmounting transition\n            break;\n          case 'unmountPending':\n            toggleTimeoutClear();\n            setState('mounted'); // Clear timers immediately and keep the tooltip mounted\n            break;\n        }\n      } else {\n        // No toggle events are set to true\n        switch (state) {\n          case 'mounting':\n          case 'mounted':\n            setState('unmountPending'); // Set unmount pending state if tooltip is mounted or in mounting transition\n            break;\n          case 'mountPending':\n            toggleTimeoutClear();\n            setState('unmounted'); // Unmount tooltip immediately if mounting is pending\n            break;\n        }\n      }\n    },\n    [state]\n  );\n\n  useEffect(() => {\n    if (isInitialRenderState.current) {\n      // On onitial render do not trigger rerender\n      isInitialRenderState.current = false;\n      return;\n    }\n    setState(isOpen ? 'mounting' : 'unmounting');\n  }, [isOpen]);\n\n  useEffect(() => {\n    if (isInitialRenderTrigger.current) {\n      // On onitial render do not trigger rerender\n      isInitialRenderTrigger.current = false;\n      return;\n    }\n    // When pointer is used, handleMouseMove method is responsible for state updates\n    // until the tooltip is mounted\n    if (isPointer && isHover && state === 'unmounted') {\n      return;\n    }\n    updateTimeoutClear();\n    // isHover and popoverIsHover may change rapidly as the pointer moves between the target\n    // and tooltip. Need to wait for changes to settle to avoid flashing.\n    updateTimeoutRef.current = setTimeout(() => {\n      updateState(isHover || isFocus || popoverIsHover || isTouch);\n    }, 20);\n  }, [isHover, isFocus, popoverIsHover, isTouch, isPointer, state, updateState]);\n\n  /*\n   In some cases, several state transitions can occur at once. Due to the asynchronous nature\n   of hooks, this can create a race condition. For example, when the cursor leaves the target\n   element and immediately moves to the tooltip itself, the following sequence occurs:\n   1. isHover is set to false and a new render is triggered\n   2. The state is set to 'unmountPending' and a new render is triggered\n   3. Pending timeout is set\n   4. isHover is set to true and a new render is triggered\n   5. Pending timeout is cleared\n   However, sometimes the timeout is cleared before it is set. The useLayoutEffect prevents this\n   race condition by always scheduling the timeout synchronously.\n  */\n  useLayoutEffect(() => {\n    if (state === 'mountPending' || state === 'unmountPending') {\n      toggleTimeoutRef.current = setTimeout(\n        () => onToggle?.({ value: state === 'mountPending' }),\n        delay\n      );\n    }\n  }, [state, delay, onToggle]);\n\n  const handleMouseMove = (event: MouseEvent) => {\n    // we only want track mouse move while the state is 'unmounted' or when moving a 'mounted' datatip\n    if (state !== 'unmounted' && !(variant === 'datatip' && state === 'mounted')) {\n      return;\n    }\n    const targetRect = targetRef?.current?.getBoundingClientRect();\n\n    // Tooltip maintains static offset from left side of window\n    const distanceX = document.body.scrollLeft + (targetRect?.left || 0) + (targetRect?.width || 0);\n\n    // Tooltip maintains static offset from top side of the window\n    const distanceY = document.body.scrollTop + (targetRect?.top || 0) + (targetRect?.height || 0);\n\n    // Display tooltip at the mouse position if both anchors are set to pointer\n    const x = anchor.x === 'pointer' ? event.clientX : distanceX;\n    const y = anchor.y === 'pointer' ? event.clientY : distanceY;\n\n    if (state === 'mounted') {\n      coordsRef.current = { x, y };\n      if (needsUpdate !== true) setNeedsUpdate(true);\n    } else if (state === 'unmounted') {\n      toggleTimeoutClear();\n      toggleTimeoutRef.current = setTimeout(() => {\n        if (state === 'unmounted') {\n          coordsRef.current = { x, y };\n          onToggle?.({ value: true });\n        }\n      }, delay);\n    }\n  };\n\n  const focusInitProps = {\n    onFocus: (event: FocusEvent) => {\n      if (\n        event.eventPhase === Event.AT_TARGET ||\n        (event.eventPhase === Event.BUBBLING_PHASE && isDatatip)\n      ) {\n        targetRef.current = event.target as HTMLElement;\n      }\n    }\n  };\n\n  let actionableProps;\n  if (disabled) {\n    actionableProps = mergeProps(focusProps, focusInitProps);\n  } else {\n    const anchorInitProps = {\n      'aria-describedby': uniqueID,\n      onMouseEnter: (event: MouseEvent) => {\n        if (\n          event.eventPhase === Event.AT_TARGET ||\n          (event.eventPhase === Event.BUBBLING_PHASE && isDatatip)\n        ) {\n          targetRef.current = event.target as HTMLElement;\n        }\n      },\n      ...(isPointer && {\n        onMouseLeave: () => {\n          if (state === 'mounting') {\n            return;\n          }\n          toggleTimeoutClear();\n        },\n        onMouseMove: (event: MouseEvent) => {\n          if (\n            event.eventPhase === Event.AT_TARGET ||\n            (event.eventPhase === Event.BUBBLING_PHASE && isDatatip)\n          ) {\n            handleMouseMove(event);\n          }\n        }\n      })\n    };\n    actionableProps = mergeProps(\n      hoverProps,\n      focusProps,\n      touchProps,\n      focusInitProps,\n      anchorInitProps\n    );\n  }\n\n  // No need to process tooltip if disabled or no text is provided\n  // Include actionableProps to detect mouseenter in components\n  // hovered state won't update unless actionableProps are already present in the component when mouse enters\n  if (disabled) {\n    toggleTimeoutClear();\n    return {\n      tooltipContent: null,\n      tooltipProps: actionableProps\n    };\n  }\n\n  const placement = positionToPlacement(position);\n\n  const handleTransitionEnd = () => {\n    if (state === 'mounting') {\n      setState('mounted');\n    }\n    if (state === 'unmounting') {\n      setState('unmounted');\n    }\n  };\n\n  const renderContent = (\n    <Layer logicalParentRef={targetRef}>\n      <Floating anchorRef={usedRef} placement={placement} offsetValue={offset}>\n        <TooltipContent\n          isOpen={['mounting', 'mounted', 'unmountPending'].includes(state)}\n          {...popoverHoverProps}\n          isDatatip={isDatatip}\n          onTransitionEnd={handleTransitionEnd}>\n          {text}\n        </TooltipContent>\n      </Floating>\n    </Layer>\n  );\n\n  return {\n    tooltipContent: !['unmounted', 'mountPending'].includes(state) && renderContent,\n    tooltipProps: actionableProps\n  };\n};\n","import { useState } from 'preact/hooks';\nimport { useTooltipControlled } from './useTooltipControlled';\n\ntype tooltipParameters = Parameters<typeof useTooltipControlled>[0];\n\ntype Props = {\n  text?: string;\n  position?: tooltipParameters['position'];\n  isDisabled?: boolean;\n  anchor?: tooltipParameters['anchor'];\n  offset?: { mainAxis?: number; crossAxis?: number };\n  variant?: tooltipParameters['variant'];\n};\n\nexport const useTooltip = ({\n  text,\n  position = 'bottom',\n  isDisabled = false,\n  anchor = { x: 'element', y: 'element' },\n  offset = { mainAxis: 0, crossAxis: 0 },\n  variant = 'tooltip'\n}: Props): ReturnType<typeof useTooltipControlled> => {\n  const [isOpen, setIsOpen] = useState<boolean>(false);\n  const disabled = isDisabled || !text;\n  const { tooltipContent, tooltipProps } = useTooltipControlled({\n    text,\n    isOpen,\n    position,\n    isDisabled: disabled,\n    offset,\n    anchor,\n    variant,\n    onToggle: ({ value }) => setIsOpen(value)\n  });\n\n  return {\n    tooltipContent,\n    tooltipProps\n  };\n};\n"],"names":["styles","TooltipContent","_a","children","isOpen","isDatatip","onTransitionEnd","props","__rest","uniqueID","useId","wrapperRef","useRef","popoverRef","nodeRef","useAnimation","animationStates","mounted","_node","childNode","firstChild","from","maxHeight","opacity","to","options","unmounted","isAnimatedOnMount","current","style","height","_b","offsetHeight","_jsx","Object","assign","ref","id","role","class","jsx","classNames","useTooltipControlled","stringLiteralArray","text","variant","position","isDisabled","anchor","x","y","offset","mainAxis","crossAxis","onToggle","disabled","isInitialRenderState","state","setState","useState","needsUpdate","setNeedsUpdate","isInitialRenderTrigger","hoverProps","isHover","useHover","touchProps","isTouch","useTouch","focusProps","isFocus","useFocus","popoverHoverProps","popoverIsHover","isPointer","targetRef","coordsRef","usedRef","delay","toggleTimeoutRef","updateTimeoutRef","toggleTimeoutClear","clearTimeout","updateState","useCallback","open","useEffect","setTimeout","useLayoutEffect","value","focusInitProps","onFocus","event","eventPhase","Event","AT_TARGET","BUBBLING_PHASE","target","actionableProps","mergeProps","anchorInitProps","onMouseEnter","onMouseLeave","onMouseMove","targetRect","getBoundingClientRect","distanceX","document","body","scrollLeft","left","width","distanceY","scrollTop","top","clientX","clientY","handleMouseMove","tooltipContent","tooltipProps","placement","positionToPlacement","renderContent","Layer","logicalParentRef","Floating","anchorRef","offsetValue","includes","setIsOpen"],"mappings":"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"}