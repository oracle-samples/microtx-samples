{"version":3,"file":"PRIVATE_useCurrentKey.js","sources":["../../../src/hooks/PRIVATE_useCurrentKey/useCurrentKey.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback } from 'preact/hooks';\nimport { isKeyDefined } from '../../utils/UNSAFE_keys';\nimport { CurrentKeyDetail } from '../../UNSAFE_Collection';\n\n/**\n * Hook for handling current key update due to user interaction including keyboard navigation.\n * This can be reuse by all Collection components.\n *\n * @param keyExtractor function to extract the key based on the provided element\n * @param getPrevKey function to get the previous key based on the current key\n * @param getNextKey function to get the next key based on the current key\n * @param currentKey the current key\n * @param onCurrentChange function to invoke if the current key has changed\n * @returns\n */\nexport function useCurrentKey<K>(\n  keyExtractor: (element: HTMLElement) => K | null,\n  getPrevKey: () => K | null,\n  getNextKey: () => K | null,\n  currentKey?: K,\n  onChange?: (detail: CurrentKeyDetail<K>) => void\n) {\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (onChange && isKeyDefined(currentKey)) {\n        // TODO: support horizontal layout (left/right arrow key)\n        if (event.key === 'ArrowDown' && !event.shiftKey) {\n          const nextKey = getNextKey();\n          if (isKeyDefined(nextKey) && currentKey != nextKey) {\n            onChange({ value: nextKey as K });\n          }\n          event.preventDefault();\n        } else if (event.key === 'ArrowUp' && !event.shiftKey) {\n          const prevKey = getPrevKey();\n          if (isKeyDefined(prevKey) && currentKey != prevKey) {\n            onChange({ value: prevKey as K });\n          }\n          event.preventDefault();\n        }\n      }\n    },\n    [currentKey, getNextKey, getPrevKey, onChange]\n  );\n\n  const onClick = useCallback(\n    (event: MouseEvent) => {\n      if (onChange && !event.shiftKey) {\n        const nextKey = keyExtractor(event.target as HTMLElement);\n        if (isKeyDefined(nextKey) && currentKey != nextKey) {\n          onChange({ value: nextKey as K });\n          event.stopPropagation();\n        }\n      }\n    },\n    [currentKey, keyExtractor, onChange]\n  );\n\n  const currentKeyProps = onChange == null ? {} : { onClick, onKeyDown };\n  return { currentKeyProps };\n}\n"],"names":["keyExtractor","getPrevKey","getNextKey","currentKey","onChange","onKeyDown","useCallback","event","isKeyDefined","key","shiftKey","prevKey","value","preventDefault","nextKey","onClick","target","stopPropagation","currentKeyProps"],"mappings":"sGAsBM,SACJA,EACAC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAYC,cACfC,IACC,GAAIH,GAAYI,eAAaL,GAE3B,GAAkB,cAAdI,EAAME,KAAwBF,EAAMG,UAMjC,GAAkB,YAAdH,EAAME,MAAsBF,EAAMG,SAAU,CACrD,MAAMC,EAAUV,IACZO,eAAaG,IAAYR,GAAcQ,GACzCP,EAAS,CAAEQ,MAAOD,IAEpBJ,EAAMM,sBAX0C,CAChD,MAAMC,EAAUZ,IACZM,eAAaM,IAAYX,GAAcW,GACzCV,EAAS,CAAEQ,MAAOE,IAEpBP,EAAMM,mBAUZ,CAACV,EAAYD,EAAYD,EAAYG,IAGjCW,EAAUT,cACbC,IACC,GAAIH,IAAaG,EAAMG,SAAU,CAC/B,MAAMI,EAAUd,EAAaO,EAAMS,QAC/BR,eAAaM,IAAYX,GAAcW,IACzCV,EAAS,CAAEQ,MAAOE,IAClBP,EAAMU,qBAIZ,CAACd,EAAYH,EAAcI,IAI7B,MAAO,CAAEc,gBAD2B,MAAZd,EAAmB,GAAK,CAAEW,QAAAA,EAASV,UAAAA"}