{"version":3,"file":"Menu-10a5b1e6.js","sources":["../../src/UNSAFE_Menu/menuUtils.ts","../../src/UNSAFE_Menu/Menu.tsx","../../src/UNSAFE_Menu/useMenuCurrentKey.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ComponentProps } from 'preact';\n\nimport { Menu } from './Menu';\n\n/**\n * Returns the key from the item element\n */\nconst getKey = (item: HTMLElement) => {\n  // Key is set on data-oj-menu-item-key on each menuItem. To get this key from the\n  // the actual menuItem we need to do a kebab to camel-case conversion.\n  return item.dataset['ojMenuItemKey'];\n};\n\n/**\n * A helper function that return the key of the first available item.\n */\nexport const getFirstVisibleKey = (root: HTMLElement | null) => {\n  if (root) {\n    const firstItem = root.querySelector('[data-oj-menu-item-key]');\n    if (firstItem) {\n      const key = getKey(firstItem as HTMLElement);\n      if (key) {\n        return key;\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * A helper function that return the key of the last available item.\n */\nexport const getLastVisibleKey = (root: HTMLElement | null) => {\n  if (root) {\n    const items = root.querySelectorAll('[data-oj-menu-item-key]');\n    const lastItem = items[items.length - 1];\n    if (lastItem) {\n      const key = getKey(lastItem as HTMLElement);\n      if (key) {\n        return key;\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * A helper function that returns the key of the previous or the next item\n * given the specified current key\n */\nexport const getPrevNextKey = (root: HTMLElement | null, isPrev: boolean, currentKey?: string) => {\n  return (): string | null => {\n    if (root) {\n      const items = Array.from(root.querySelectorAll('[data-oj-menu-item-key]')) as HTMLElement[];\n      const currentKeyIndex = items.findIndex((item) => getKey(item) === currentKey);\n      let nextIndex = currentKeyIndex + (isPrev ? -1 : 1);\n      const itemsLastIndex = items.length - 1;\n      if (nextIndex < 0) {\n        nextIndex = itemsLastIndex;\n      }\n      if (nextIndex > itemsLastIndex) {\n        nextIndex = 0;\n      }\n      return getKey(items[nextIndex]) || null;\n    }\n    return null;\n  };\n};\n\n/**\n * A helper function to get the key from an element\n */\nexport const keyExtractor = (element: HTMLElement): string | null => {\n  const item = element.closest('[data-oj-menu-item-key]');\n  if (item) {\n    const key = getKey(item as HTMLElement);\n    return key === undefined ? null : key;\n  }\n  return null;\n};\n\n/**\n * Function to get the corresponding keyboard behavior to close the menu.\n */\nexport const getKeyboardCloseProps = (onClose: ComponentProps<typeof Menu>['onClose']) => {\n  const onKeyDown = (event: KeyboardEvent) => {\n    if (event.key === 'Tab') {\n      onClose?.({ reason: 'tabbing' });\n      event.preventDefault(); //TODO: Revisit this since we should let focus be at its natural flow, quick solution for now to focus correct item in main use case\n    } else if (event.key === 'Escape') {\n      onClose?.({ reason: 'cancel' });\n    }\n  };\n  return { onKeyDown };\n};\n\n/**\n * Function to get the corresponding specific behavior for clicking/touching down menuContainer\n */\nexport const getMenuPointerDown = () => {\n  const onPointerDown = (event: PointerEvent) => {\n    //We just want to prevent default when element that was\n    //pressed down was not a menu item. Using this flag removes issues\n    //related to focus visibilty on \"long press\"\n    const nextKey = keyExtractor(event.target as HTMLElement);\n    if (!nextKey) {\n      event.preventDefault();\n    }\n  };\n  return { onPointerDown };\n};\n\nexport type MenuValueUpdateDetail<T> = {\n  previousValue?: T;\n  value: T;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { RefObject, ComponentChildren } from 'preact';\nimport { useCallback, useEffect, useRef, useState } from 'preact/hooks';\n\nimport { CurrentKeyDetail } from '../UNSAFE_Collection';\nimport { Floating } from '../UNSAFE_Floating';\nimport { Layer } from '../UNSAFE_Layer';\nimport { useOutsideClick } from '../hooks/UNSAFE_useOutsideClick';\nimport { useCollectionFocusRing } from '../hooks/PRIVATE_useCollectionFocusRing';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { cssProps } from '@oracle/oraclejet-cssprops';\n\nimport { MenuContext } from './MenuContext';\nimport { useMenuCurrentKey } from './useMenuCurrentKey';\nimport {\n  getPrevNextKey,\n  getFirstVisibleKey,\n  keyExtractor,\n  getLastVisibleKey,\n  getKeyboardCloseProps,\n  getMenuPointerDown\n} from './menuUtils';\n\ntype MenuProps = {\n  /**\n   * Trigger element reference\n   */\n  anchorRef: RefObject<HTMLElement>;\n  /**\n   * Set of menu groups or menu items that menu will hold.Even though you could pass other type of children,\n   * is strongly recommended to use MenuItem, menu groups or components that return this type of components\n   * since passing other type of components children produces not desirable behaviors.\n   */\n  children: ComponentChildren;\n  /**\n   * Specifies if menu is opened.\n   */\n  isOpen?: boolean;\n  /**\n   * Property that triggers a callback when menu is supposed to be closed.\n   */\n  onClose?: (detail: CloseDetail) => void;\n  /**\n   * Specifies some screen reader text. Set it to create an accesible menu.\n   */\n  accessibleLabel?: string;\n  /**\n   *  Determines focus behavior when the menu is opened.\n   */\n  initialFocus?: 'menu' | 'firstItem';\n};\n\ntype CloseDetail =\n  | {\n      reason: 'cancel' | 'tabbing' | 'itemAction';\n    }\n  | {\n      reason: 'outsideClick';\n      target: Element;\n    };\n\nconst styles = {\n  // TODO: Handle vertical and horizontal overflow. Get rid of maxWidth on a next drop so horizontal and also vertical flow is handled correctly.\n  // It's hard to relay just in css, we might need to relay on some kind of observer. Maybe should be handled on Floating/Dropdown component.\n  floatingContainer: cssProps`${{\n    maxWidth: '90vw',\n    width: 'max-content',\n    borderRadius: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-border-radius-lg)',\n    boxShadow: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-dropdown-box-shadow)',\n    backgroundColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-bg-color-content)'\n  }}`,\n  menuContainer: cssProps`${{\n    outlineStyle: 'none',\n    // paddingTop and Bottom here so menuConatiner have same size as floatingContainer so click event has\n    // same clickable area and we can handle focus behavior\n    paddingTop: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-spacing-2x)',\n    paddingBottom: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-spacing-2x)'\n  }}`\n};\n\nexport const Menu = ({\n  children,\n  isOpen = false,\n  anchorRef,\n  onClose,\n  accessibleLabel,\n  initialFocus = 'menu'\n}: MenuProps) => {\n  const floatingRef = useRef<HTMLElement | null>(null);\n  const menuContainerRef = useRef<HTMLDivElement | null>(null);\n  const isOpenPrevValue = useRef<boolean>();\n\n  const [currentKey, setCurrentKey] = useState<string | undefined>();\n\n  const [possibleFocus, setPossibleFocus] = useState<'pending' | 'menu' | 'firstItem'>('pending');\n\n  const changeKey = useCallback((detail: CurrentKeyDetail<string>) => {\n    setCurrentKey(detail.value);\n    setPossibleFocus('firstItem');\n  }, []);\n\n  const [showFocusRing, focusRingProps] = useCollectionFocusRing(\n    (elem: Element | null) => {\n      return !!menuContainerRef.current?.contains(elem);\n    },\n    ['ArrowUp', 'ArrowDown'],\n    (elem: Element) => {\n      const nextKey = keyExtractor(elem as HTMLElement);\n      return !!nextKey;\n    }\n  );\n\n  const { currentKeyProps } = useMenuCurrentKey(\n    (element) => keyExtractor(element),\n    getPrevNextKey(menuContainerRef.current, true, currentKey),\n    getPrevNextKey(menuContainerRef.current, false, currentKey),\n    () => getFirstVisibleKey(menuContainerRef.current),\n    () => getLastVisibleKey(menuContainerRef.current),\n    currentKey,\n    changeKey\n  );\n\n  const useOutsideClickHandler = useCallback(\n    (e: MouseEvent) => {\n      onClose?.({ reason: 'outsideClick', target: e.target as Element });\n    },\n    [onClose]\n  );\n\n  useOutsideClick({\n    isDisabled: !isOpen,\n    ref: [floatingRef],\n    handler: useOutsideClickHandler\n  });\n\n  useEffect(() => {\n    if (isOpen === isOpenPrevValue.current) return;\n\n    if (isOpen) {\n      const menuContainer = menuContainerRef.current;\n      if (menuContainer) {\n        if (initialFocus === 'menu') {\n          // At this point floating has visibility set as hidden, so also menuContainer. Settimeout added so menuContainer\n          // is visible at that point and can be focused\n          setTimeout(() => {\n            menuContainer.focus();\n          }, 0);\n          setPossibleFocus('menu');\n        } else {\n          const firstItemKey = getFirstVisibleKey(menuContainerRef.current);\n          if (firstItemKey) {\n            changeKey({ value: firstItemKey });\n          } else {\n            setPossibleFocus('menu');\n          }\n        }\n      }\n    } else {\n      setPossibleFocus('pending');\n      setCurrentKey(undefined);\n    }\n\n    isOpenPrevValue.current = isOpen;\n  }, [isOpen, initialFocus, changeKey]);\n\n  // TODO - Reuse a dropdown component instead of creating floating by ourselves.\n  return !isOpen ? null : (\n    <Layer logicalParentRef={anchorRef}>\n      <Floating\n        class={styles.floatingContainer}\n        ref={floatingRef}\n        anchorRef={anchorRef}\n        placement=\"bottom-start\"\n        offsetValue={{\n          mainAxis: 4, //TODO: stable does not have a 4px gap, so we'll need to figure out how to make this themable.\n          crossAxis: 0\n        }}>\n        <MenuContext.Provider\n          value={{\n            onClose,\n            currentKey,\n            showFocusRing\n          }}>\n          <div\n            style={{\n              minWidth: `${\n                anchorRef.current && anchorRef.current.offsetWidth > MENU_MIN_WIDTH\n                  ? anchorRef.current.offsetWidth\n                  : MENU_MIN_WIDTH\n              }px`\n            }}\n            ref={menuContainerRef}\n            tabIndex={possibleFocus === 'firstItem' ? -1 : 0}\n            role=\"menu\"\n            aria-label={accessibleLabel}\n            class={styles.menuContainer}\n            {...mergeProps(\n              focusRingProps,\n              currentKeyProps,\n              getMenuPointerDown(),\n              getKeyboardCloseProps(onClose)\n            )}>\n            {children}\n          </div>\n        </MenuContext.Provider>\n      </Floating>\n    </Layer>\n  );\n};\n\nconst MENU_MIN_WIDTH = 200;\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback } from 'preact/hooks';\n\nimport { CurrentKeyDetail } from '../UNSAFE_Collection';\n\n/**\n * Hook for handling current key update due to user interaction including keyboard navigation.\n *\n * @param keyExtractor function to extract the key based on the provided element\n * @param getPrevKey function to get the previous key based on the current key\n * @param getNextKey function to get the next key based on the current key\n * @param getFirstVisibleKey function to get the key of the first available item\n * @param getLastVisibleKey function to get the key of the last available item\n * @param currentKey the current key\n * @param onChange function to invoke if the current key has changed\n * @returns\n */\nexport function useMenuCurrentKey(\n  keyExtractor: (element: HTMLElement) => string | null,\n  getPrevKey: () => string | null,\n  getNextKey: () => string | null,\n  getFirstVisibleKey: () => string | null,\n  getLastVisibleKey: () => string | null,\n  currentKey?: string,\n  onChange?: (detail: CurrentKeyDetail<string>) => void\n) {\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (onChange) {\n        // TODO: support horizontal layout on icon menu (left/right arrow key)\n        if (event.key === 'ArrowDown' && !event.shiftKey) {\n          const nextKey = getNextKey();\n          if (nextKey && currentKey != nextKey) {\n            onChange({ value: nextKey });\n          }\n          event.preventDefault();\n        } else if (event.key === 'ArrowUp' && !event.shiftKey) {\n          const prevKey = getPrevKey();\n          if (prevKey && currentKey != prevKey) {\n            onChange({ value: prevKey });\n          }\n          event.preventDefault();\n        } else if (event.key === 'Home') {\n          const firstKey = getFirstVisibleKey();\n          if (firstKey && currentKey != firstKey) {\n            onChange({ value: firstKey });\n          }\n          event.preventDefault();\n        } else if (event.key === 'End') {\n          const lastKey = getLastVisibleKey();\n          if (lastKey && currentKey != lastKey) {\n            onChange({ value: lastKey });\n          }\n          event.preventDefault();\n        }\n      }\n    },\n    [currentKey, getNextKey, getPrevKey, onChange, getFirstVisibleKey, getLastVisibleKey]\n  );\n  //Capture needed since usePress stop propagation, what produces not triggering this event.\n  //We can't stop propagation here, because if we do that, usePress onClick will not be triggered.\n  const onClickCapture = useCallback(\n    (event: MouseEvent) => {\n      if (onChange && !event.shiftKey) {\n        const nextKey = keyExtractor(event.target as HTMLElement);\n        if (nextKey && currentKey != nextKey) {\n          onChange({ value: nextKey });\n        }\n      }\n    },\n    [currentKey, keyExtractor, onChange]\n  );\n\n  const currentKeyProps = onChange == null ? {} : { onClickCapture, onKeyDown };\n  return { currentKeyProps };\n}\n"],"names":["getKey","item","dataset","getFirstVisibleKey","root","firstItem","querySelector","key","getPrevNextKey","isPrev","currentKey","items","Array","from","querySelectorAll","nextIndex","findIndex","itemsLastIndex","length","keyExtractor","element","closest","undefined","getKeyboardCloseProps","onClose","onKeyDown","event","reason","preventDefault","styles","MENU_MIN_WIDTH","children","isOpen","anchorRef","accessibleLabel","initialFocus","floatingRef","useRef","menuContainerRef","isOpenPrevValue","changeKey","useCallback","detail","setCurrentKey","value","_a","current","contains","elem","currentKeyProps","getPrevKey","getNextKey","getLastVisibleKey","onChange","shiftKey","firstKey","lastKey","prevKey","nextKey","onClickCapture","target","useMenuCurrentKey","lastItem","useOutsideClickHandler","e","useOutsideClick","handler","menuContainer","firstItemKey","_jsx","jsx","Layer","Object","assign","logicalParentRef","Floating","class","ref","placement","offsetValue","mainAxis","crossAxis","MenuContext","Provider","minWidth","offsetWidth","onPointerDown"],"mappings":"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"}