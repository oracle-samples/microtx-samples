{"version":3,"file":"UNSAFE_useSwipe.js","sources":["../../../src/hooks/UNSAFE_useSwipe/useSwipe.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useRef, useCallback } from 'preact/hooks';\n\n/*\n  threshold: Minimal threshold required before recognizing\n  tolerance: A tolerance value which allows the user to move their finger about a length measured in pixels.\n  This allows the swipe gesture to be triggered more easily since a User might not move their finger\n  in a straight line.\n*/\ntype SwipeOptions = {\n  threshold?: number;\n  maximumTime?: number;\n  tolerance?: number;\n  isDisabled?: boolean;\n};\n\ntype SwipeInfo = {\n  direction: 'left' | 'right' | 'up' | 'down';\n};\n\ntype SwipeState = {\n  pointerDownId: number | null;\n  startTime: number | null;\n  prevoffsetX: number;\n  prevoffsetY: number;\n};\n\nexport function useSwipe(\n  onSwipe: (e: SwipeInfo) => void,\n  { threshold = 10, maximumTime = 300, tolerance = 50, isDisabled = false }: SwipeOptions = {\n    threshold: 10,\n    maximumTime: 300,\n    tolerance: 50,\n    isDisabled: false\n  }\n): { swipeProps: Record<string, any> } {\n  const ref = useRef<SwipeState>({\n    pointerDownId: 0,\n    startTime: null,\n    prevoffsetX: 0,\n    prevoffsetY: 0\n  });\n\n  const onPointerDown = useCallback((e: PointerEvent) => {\n    if (!ref.current.pointerDownId) {\n      ref.current = {\n        pointerDownId: e.pointerId,\n        startTime: e.timeStamp,\n        prevoffsetX: e.offsetX,\n        prevoffsetY: e.offsetY\n      };\n    } else {\n      clearSwipe();\n    }\n  }, []);\n\n  const onPointerUp = useCallback(\n    (ev: PointerEvent) => {\n      if (ev.pointerId === ref.current.pointerDownId) {\n        if (ref.current.startTime && ev.timeStamp - ref.current.startTime < maximumTime) {\n          if (\n            ref.current.prevoffsetX - ev.offsetX > threshold &&\n            Math.abs(ev.offsetY - ref.current.prevoffsetY) <= tolerance\n          ) {\n            onSwipe?.({ direction: 'left' });\n          } else if (\n            ev.offsetX - ref.current.prevoffsetX > threshold &&\n            Math.abs(ev.offsetY - ref.current.prevoffsetY) <= tolerance\n          ) {\n            onSwipe?.({ direction: 'right' });\n          } else if (\n            ref.current.prevoffsetY - ev.offsetY > threshold &&\n            Math.abs(ev.offsetX - ref.current.prevoffsetX) <= tolerance\n          ) {\n            onSwipe?.({ direction: 'up' });\n          } else if (\n            ev.offsetY - ref.current.prevoffsetY > threshold &&\n            Math.abs(ev.offsetX - ref.current.prevoffsetX) <= tolerance\n          ) {\n            onSwipe?.({ direction: 'down' });\n          }\n        }\n      }\n      // state would be reset to its original state whether swipe is completed or cancelled\n      clearSwipe();\n    },\n    [threshold, onSwipe]\n  );\n\n  const clearSwipe = useCallback(() => {\n    ref.current = {\n      pointerDownId: null,\n      startTime: 0,\n      prevoffsetX: 0,\n      prevoffsetY: 0\n    };\n  }, []);\n\n  const swipeProps = isDisabled\n    ? {}\n    : {\n        /** event handlers to spread on the target element. */\n        onPointerDown,\n        onPointerUp,\n        onPointerCancel: clearSwipe\n      };\n\n  return {\n    swipeProps\n  };\n}\n"],"names":["onSwipe","threshold","maximumTime","tolerance","isDisabled","ref","useRef","pointerDownId","startTime","prevoffsetX","prevoffsetY","onPointerDown","useCallback","e","current","clearSwipe","pointerId","timeStamp","offsetX","offsetY","onPointerUp","ev","Math","abs","direction","swipeProps","onPointerCancel"],"mappings":"wEAkCM,SACJA,GACAC,UAAEA,EAAY,GAAdC,YAAkBA,EAAc,IAAhCC,UAAqCA,EAAY,GAAjDC,WAAqDA,GAAa,GAAwB,CACxFH,UAAW,GACXC,YAAa,IACbC,UAAW,GACXC,YAAY,IAGd,MAAMC,EAAMC,EAAAA,OAAmB,CAC7BC,cAAe,EACfC,UAAW,KACXC,YAAa,EACbC,YAAa,IAGTC,EAAgBC,cAAaC,IAC5BR,EAAIS,QAAQP,cAQfQ,IAPAV,EAAIS,QAAU,CACZP,cAAeM,EAAEG,UACjBR,UAAWK,EAAEI,UACbR,YAAaI,EAAEK,QACfR,YAAaG,EAAEM,UAKlB,IAEGC,EAAcR,cACjBS,IACKA,EAAGL,YAAcX,EAAIS,QAAQP,eAC3BF,EAAIS,QAAQN,WAAaa,EAAGJ,UAAYZ,EAAIS,QAAQN,UAAYN,IAEhEG,EAAIS,QAAQL,YAAcY,EAAGH,QAAUjB,GACvCqB,KAAKC,IAAIF,EAAGF,QAAUd,EAAIS,QAAQJ,cAAgBP,EAElDH,MAAAA,GAAAA,EAAU,CAAEwB,UAAW,SAEvBH,EAAGH,QAAUb,EAAIS,QAAQL,YAAcR,GACvCqB,KAAKC,IAAIF,EAAGF,QAAUd,EAAIS,QAAQJ,cAAgBP,EAElDH,MAAAA,GAAAA,EAAU,CAAEwB,UAAW,UAEvBnB,EAAIS,QAAQJ,YAAcW,EAAGF,QAAUlB,GACvCqB,KAAKC,IAAIF,EAAGH,QAAUb,EAAIS,QAAQL,cAAgBN,EAElDH,MAAAA,GAAAA,EAAU,CAAEwB,UAAW,OAEvBH,EAAGF,QAAUd,EAAIS,QAAQJ,YAAcT,GACvCqB,KAAKC,IAAIF,EAAGH,QAAUb,EAAIS,QAAQL,cAAgBN,IAElDH,MAAAA,GAAAA,EAAU,CAAEwB,UAAW,WAK7BT,KAEF,CAACd,EAAWD,IAGRe,EAAaH,EAAAA,YAAY,KAC7BP,EAAIS,QAAU,CACZP,cAAe,KACfC,UAAW,EACXC,YAAa,EACbC,YAAa,IAEd,IAWH,MAAO,CACLe,WAViBrB,EACf,GACA,CAEEO,cAAAA,EACAS,YAAAA,EACAM,gBAAiBX"}