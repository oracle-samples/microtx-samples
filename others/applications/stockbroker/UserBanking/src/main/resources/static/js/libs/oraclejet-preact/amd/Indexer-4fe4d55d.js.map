{"version":3,"file":"Indexer-4fe4d55d.js","sources":["../../src/UNSAFE_Indexer/IndexerItems.tsx","../../src/UNSAFE_Indexer/Indexer.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Fragment } from 'preact';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { cssProps } from '@oracle/oraclejet-cssprops';\nimport { Flex } from '../UNSAFE_Flex';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\nimport { ItemContext } from 'src/UNSAFE_Collection';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\n\n/**\n * Type of a section\n */\nexport type Section<K> = {\n  /**\n   * The key of each section\n   */\n  key: K;\n  /**\n   * The label of each section\n   */\n  label?: string;\n  /**\n   * A property that indicates whether the section\n   * is disabled or not. Typically, when Indexer is\n   * used with ListView, a disabled section implies\n   * that there's no corresponding items in the ListView\n   */\n  isDisabled?: boolean;\n};\n\n/**\n * The others section variable that application could use\n * to compare value\n */\n// const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\nexport const SECTION_OTHERS: Section<string> = Object.freeze({\n  key: '__others__',\n  label: '#'\n});\n\nconst liStyles = {\n  base: cssProps`${{\n    textAlign: 'center',\n    height: '1rem',\n    width: '1.5rem',\n    color: 'var(--oj-c-PRIVATE-DO-NOT-USE-indexer-text-color)',\n    fontSize: 'var(--oj-c-PRIVATE-DO-NOT-USE-indexer-font-size)',\n    lineHeight: '1rem'\n  }}`,\n  disabled: cssProps`${{\n    color: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-text-color-disabled)'\n  }}`,\n  focused: cssProps`${{\n    outlineStyle: 'dotted',\n    outlineWidth: '1px',\n    outlineColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-focus-border-color)',\n    outlineOffset: '-1px'\n  }}`,\n  selected: cssProps`${{\n    fontWeight: 'bold'\n  }}`\n};\n\nconst ITEM_STYLE_CLASS = liStyles.base;\nexport const ITEM_SELECTOR = '.' + ITEM_STYLE_CLASS;\n\nconst dotStyles = {\n  base: cssProps`${{\n    '&::after': {\n      content: '\"\\u25cf\"'\n    }\n  }}`\n};\n\nexport type SectionProps<K> = {\n  context: ItemContext<Section<K>>;\n  currentKey: K;\n  selectedKey: K;\n  valueNow: number; // the index of an item within currently visible sections\n  isFocusRingVisible: boolean;\n};\n\nexport const SectionItem = forwardRef(\n  <K extends string | number>(props: SectionProps<K>, ref: ForwardedRef<HTMLLIElement>) => {\n    const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n    const { context, selectedKey } = props;\n    const isSelected = context.data.key === selectedKey;\n    const commonProps = getCommonProps(props, ref);\n\n    const itemClasses = classNames([\n      commonProps.class,\n      context.data.isDisabled && liStyles.disabled,\n      isSelected && liStyles.selected\n    ]);\n\n    const sectionLabel = context.data.label || context.data.key;\n    const valueText = context.data.isDisabled\n      ? translations.indexer_disabledLabel({ SECTION: `${sectionLabel}` })\n      : `${sectionLabel}`;\n\n    return (\n      <li\n        {...commonProps}\n        class={itemClasses}\n        data-oj-valuetext={valueText}\n        data-oj-disabled={context.data.isDisabled}>\n        {context.data.label || context.data.key}\n      </li>\n    );\n  }\n);\n\nfunction getCommonProps<K>(\n  { context, currentKey, valueNow, isFocusRingVisible }: SectionProps<K>,\n  ref: ForwardedRef<HTMLLIElement>\n) {\n  const isCurrent = context.data.key === currentKey;\n  const classes = classNames([liStyles.base, isCurrent && isFocusRingVisible && liStyles.focused]);\n  return {\n    ...(isCurrent && { ref }),\n    key: context.data.key,\n    class: classes,\n    'data-oj-key': context.data.key,\n    'data-oj-key-type': typeof context.data.key,\n    'data-oj-valuenow': valueNow,\n    isFocusRingVisible: !!isFocusRingVisible\n  };\n}\n\ntype LastSectionProps<K> = SectionProps<K> & {\n  lastValueNow: number;\n};\n\n// render the last section, that contains the last character and others character\nexport const LastSectionItem = forwardRef(\n  <K extends string | number>(\n    { lastValueNow, ...sectionProps }: LastSectionProps<K>,\n    ref: ForwardedRef<HTMLLIElement>\n  ) => {\n    const commonProps = { ...sectionProps, ref };\n    return (\n      <Fragment>\n        <SectionItem {...commonProps} />\n        <OthersItem\n          {...commonProps}\n          ref={ref}\n          context={{ index: -1, data: SECTION_OTHERS } as ItemContext<Section<K>>}\n          valueNow={lastValueNow}\n        />\n      </Fragment>\n    );\n  }\n);\n\nconst OthersItem = forwardRef(<K,>(props: SectionProps<K>, ref: ForwardedRef<HTMLLIElement>) => {\n  const { context, selectedKey } = props;\n  const commonProps = getCommonProps(props, ref);\n\n  const isSelected = context.data.key === selectedKey;\n  const othersClasses = classNames([commonProps.class, isSelected && liStyles.selected]);\n  const othersValueText = SECTION_OTHERS.label;\n\n  return (\n    <li {...commonProps} class={othersClasses} data-oj-valuetext={othersValueText}>\n      {context.data.label}\n    </li>\n  );\n});\n\ntype SeparatorProps<K> = SectionProps<K> & {\n  sectionsPerTruncation: number;\n  last: number;\n  sections: Section<K>[];\n};\n\nexport const SeparatorItem = forwardRef(\n  <K extends string | number>(props: SeparatorProps<K>, ref: ForwardedRef<HTMLLIElement>) => {\n    const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n    const { context, sections } = props;\n    const commonProps = getCommonProps(props, ref);\n    const { from, to } = getSeparatorRange(props);\n\n    if (!isInSeparatorMiddle(context.index, from, to)) {\n      return null;\n    }\n\n    const fromText = sections[from].label || sections[from].key;\n    const toText = sections[to].label || sections[to].key;\n    const separatorClasses = classNames([dotStyles.base]);\n\n    const separatorValueText = translations.indexer_separatorLabel({\n      FROM_SECTION: `${fromText}`,\n      TO_SECTION: `${toText}`\n    });\n\n    return (\n      <li {...commonProps} data-oj-valuetext={separatorValueText}>\n        <Flex align=\"center\" justify=\"center\">\n          <div class={separatorClasses}></div>\n        </Flex>\n      </li>\n    );\n  }\n);\n\nexport function hasSeparator<K>(props: SeparatorProps<K>) {\n  const { from, to } = getSeparatorRange(props);\n  return isInSeparatorMiddle(props.context.index, from, to);\n}\n\nfunction getSeparatorRange<K>({ context, sectionsPerTruncation, last }: SeparatorProps<K>) {\n  const from = context.index - (context.index % sectionsPerTruncation) + 1;\n  let to = from + sectionsPerTruncation - 2;\n  to = to >= last ? last - 1 : to;\n\n  return { from, to };\n}\n\nfunction isInSeparatorMiddle(index: number, from: number, to: number) {\n  return index === Math.floor((from + to) / 2);\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren, createRef, RefObject } from 'preact';\nimport { useEffect, useRef, useState, StateUpdater, useCallback } from 'preact/hooks';\nimport { Flex } from '../UNSAFE_Flex';\nimport { cssProps } from '@oracle/oraclejet-cssprops';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { useSingleSelection } from '../hooks/PRIVATE_useSingleSelection/useSingleSelection';\nimport { useCurrentKey } from '../hooks/PRIVATE_useCurrentKey';\nimport { useCollectionFocusRing } from '../hooks/PRIVATE_useCollectionFocusRing';\nimport { keyExtractor, getPrevNextKey } from '../utils/PRIVATE_collectionUtils';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\nimport { HiddenAccessible } from '../UNSAFE_HiddenAccessible';\nimport { ItemContext, CurrentKeyDetail, SingleSelectionDetail } from '../UNSAFE_Collection';\nimport { Collection } from '../PRIVATE_Collection';\nimport {\n  Section,\n  SectionItem,\n  LastSectionItem,\n  SeparatorItem,\n  SECTION_OTHERS,\n  hasSeparator,\n  ITEM_SELECTOR\n} from './IndexerItems';\n\nexport type CommitDetail<K> = {\n  value: K;\n};\n\ntype Props<K> = {\n  /**\n   * An array of sections, the default sections is an\n   * array of 26 English alphabets and the # others character\n   */\n  sections?: Section<K>[];\n\n  /**\n   * The currently selected Section\n   */\n  value?: K;\n\n  /**\n   * A function that will be invoked when selection happens,\n   * no matter the Section was selected before or not.\n   */\n  onCommit?: (detail: CommitDetail<K>) => void;\n};\n\nconst styles = {\n  base: cssProps`${{\n    height: '100%'\n  }}`\n};\n\nconst ulStyles = {\n  base: cssProps`${{\n    listStyleType: 'none',\n    margin: '0px',\n    marginTop: 'auto', // prevent cutoff in small screen\n    marginBottom: 'auto', // prevent cutoff in small screen\n    paddingTop: '0',\n    paddingBottom: '0',\n    paddingLeft: '0',\n    paddingRight: '0',\n    outlineStyle: 'none'\n  }}`\n};\n\nconst defaultSections: Section<string>[] = [\n  { key: 'A' },\n  { key: 'B' },\n  { key: 'C' },\n  { key: 'D' },\n  { key: 'E' },\n  { key: 'F' },\n  { key: 'G' },\n  { key: 'H' },\n  { key: 'I' },\n  { key: 'J' },\n  { key: 'K' },\n  { key: 'L' },\n  { key: 'M' },\n  { key: 'N' },\n  { key: 'O' },\n  { key: 'P' },\n  { key: 'Q' },\n  { key: 'R' },\n  { key: 'S' },\n  { key: 'T' },\n  { key: 'U' },\n  { key: 'V' },\n  { key: 'W' },\n  { key: 'X' },\n  { key: 'Y' },\n  { key: 'Z' }\n];\n\n/**\n * Pure Preact based component that consumes Collection component\n * and renders an indexer.\n */\nexport function Indexer<K extends string | number>({\n  sections = defaultSections as Section<K>[],\n  value,\n  onCommit = () => {}\n}: Props<K>) {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const ulRef = useRef<HTMLUListElement>(null);\n  const currElementRef = createRef<HTMLLIElement>();\n  const [current, setCurrent] = useState<K | undefined>(sections[0]?.key);\n  // the number of sections in each truncation\n  const [sectionsPerTruncation, setSectionsPerTruncation] = useState<number>(-1);\n  // the total number of rendered sections and separators\n  const renderedSectionsCount = useRef<number>(-1);\n  const itemHeightRef = useRef<number>(0);\n  // the id for aria describedby\n  const uniqueId = useId();\n\n  const [showFocusRing, focusRingProps] = useCollectionFocusRing(\n    (elem: Element | null) => {\n      return !!rootRef.current?.contains(elem);\n    },\n    ['ArrowUp', 'ArrowDown']\n  );\n\n  const { currentKeyProps } = useCurrentKey(\n    (element) => keyExtractor(element, ITEM_SELECTOR),\n    getPrevNextKey(rootRef.current, current, true, ITEM_SELECTOR),\n    getPrevNextKey(rootRef.current, current, false, ITEM_SELECTOR),\n    current,\n    (detail: CurrentKeyDetail<K>) => setCurrent(detail.value)\n  );\n\n  const { selectionProps } = useSingleSelection(\n    (element) => handleKeyExtract(element, ulRef, current as K),\n    // pass in undefined so onCommit handler will be called\n    // no matter whether the Section was selected before or not\n    undefined,\n    (detail: SingleSelectionDetail<K>) => handleSelection(detail, onCommit, sections)\n  );\n\n  /**\n   * Item renderer that will return a section item or a section separator\n   * based on the sectionsPerTruncation and item context index.\n   * @param context item context\n   */\n  const itemRenderer = (context: ItemContext<Section<K>>): ComponentChildren => {\n    const last = sections.length - 1;\n    renderedSectionsCount.current += 1;\n\n    const commonProps = {\n      context,\n      ref: currElementRef,\n      currentKey: current as K,\n      selectedKey: value as K,\n      valueNow: renderedSectionsCount.current,\n      isFocusRingVisible: !!showFocusRing\n    };\n\n    // render the last and the others character, they are always present\n    if (context.index === last) {\n      return <LastSectionItem {...commonProps} lastValueNow={renderedSectionsCount.current + 1} />;\n    }\n\n    // render a section, in the non-truncation case or when it is the first in a truncation\n    if (sectionsPerTruncation <= 1 || context.index % sectionsPerTruncation === 0) {\n      return <SectionItem {...commonProps} />;\n    }\n\n    // render the separator in the middle of a truncation\n    const separatorProps = { ...commonProps, sectionsPerTruncation, last, sections };\n    if (hasSeparator(separatorProps)) {\n      return <SeparatorItem {...separatorProps} />;\n    }\n\n    // remove the count for truncated sections\n    renderedSectionsCount.current -= 1;\n\n    return null;\n  };\n\n  // truncate the Indexer during resize\n  const handleResize = useCallback(\n    (entries: ResizeObserverEntry[]) => {\n      for (const entry of entries) {\n        updateSectionsPerTruncation(\n          entry.contentRect.height,\n          itemHeightRef.current,\n          sections.length,\n          sections[0]?.key,\n          sectionsPerTruncation,\n          setSectionsPerTruncation,\n          setCurrent\n        );\n      }\n    },\n    [sections, sectionsPerTruncation]\n  );\n\n  useEffect(() => {\n    if (ulRef.current) {\n      // Get aria values from IndexerItem to update aria values on Indexer ul element\n      ulRef.current.setAttribute('aria-valuemax', renderedSectionsCount.current + 1 + '');\n      ulRef.current.setAttribute(\n        'aria-valuetext',\n        currElementRef.current?.dataset?.['ojValuetext'] || ''\n      );\n      ulRef.current.setAttribute(\n        'aria-valuenow',\n        currElementRef.current?.dataset?.['ojValuenow'] || ''\n      );\n    }\n    renderedSectionsCount.current = -1;\n  });\n\n  /**\n   * Set up the initial values for sectionsPerTruncation and event listeners\n   */\n  useEffect(() => {\n    const root = rootRef.current;\n    if (root) {\n      itemHeightRef.current = root.querySelector('li')?.offsetHeight || 0;\n      updateSectionsPerTruncation(\n        root.offsetHeight,\n        itemHeightRef.current,\n        sections.length,\n        sections[0]?.key,\n        sectionsPerTruncation,\n        setSectionsPerTruncation,\n        setCurrent\n      );\n    }\n  }, [sections, sectionsPerTruncation]);\n\n  /**\n   * Set up resize observer and refresh the resize observer when\n   * sectionsPerTruncation is changed, otherwise it will only have the\n   * old copy of sectionsPerTruncation.\n   */\n  useEffect(() => {\n    const root = rootRef.current;\n    if (root) {\n      const resizeObserver = new ResizeObserver((entries: ResizeObserverEntry[]) => {\n        handleResize(entries);\n      });\n      resizeObserver.observe(root);\n      return () => {\n        resizeObserver.unobserve(root);\n      };\n    }\n    return undefined;\n  }, [sectionsPerTruncation, handleResize]);\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  return (\n    <div ref={rootRef} class={styles.base}>\n      <Flex align=\"center\" width=\"6x\" height=\"100%\">\n        <ul\n          {...mergeProps(currentKeyProps, focusRingProps, selectionProps)}\n          ref={ulRef}\n          tabIndex={0}\n          aria-label=\"Indexer\"\n          aria-orientation=\"vertical\"\n          aria-valuemin=\"0\"\n          aria-describedby={uniqueId}\n          role=\"slider\"\n          class={ulStyles.base}>\n          <Collection items={sections}>{itemRenderer}</Collection>\n        </ul>\n      </Flex>\n      <HiddenAccessible>\n        <span id={uniqueId}>{getIndexerDescription(translations)}</span>\n      </HiddenAccessible>\n    </div>\n  );\n}\n\n// A function to extract key for selection\nconst handleKeyExtract = <K extends string | number>(\n  element: HTMLElement,\n  rootRef: RefObject<HTMLElement>,\n  current: K\n) => {\n  if (element === rootRef.current) {\n    return current === undefined ? null : current;\n  }\n  return keyExtractor(element, ITEM_SELECTOR) as K;\n};\n\nconst handleSelection = <K extends string | number>(\n  detail: SingleSelectionDetail<K>,\n  onCommit: (value: CommitDetail<K>) => void,\n  sections: Section<K>[]\n) => {\n  if (detail.value === SECTION_OTHERS.key) {\n    onCommit({ value: SECTION_OTHERS.key as K });\n  } else {\n    const selectedSection = sections.find((section) => section.key === detail.value) as Section<K>;\n    onCommit({ value: selectedSection.key as K });\n  }\n};\n\n/**\n * A function that calculates the section count, based on\n * the container height and the number of sections\n * @param height height of Indexer container\n */\nconst updateSectionsPerTruncation = <K extends string | number>(\n  height: number,\n  itemHeight: number,\n  sectionsLength: number,\n  firstSectionKey: K,\n  sectionsPerTruncation: number,\n  setSectionsPerTruncation: StateUpdater<number>,\n  setCurrent: StateUpdater<K | undefined>\n) => {\n  if (height === 0 || itemHeight === 0) {\n    return;\n  }\n\n  const maxSections = height / itemHeight;\n  const last = sectionsLength - 1;\n\n  // when the container size is too small to hold two sections\n  if (maxSections < 2) {\n    if (sectionsPerTruncation !== last) {\n      setSectionsPerTruncation(last);\n      setCurrent(firstSectionKey);\n    }\n\n    // no truncation\n    // compare with < 0.01 for the deviation from calculation, when sectionsLength and maxSections\n    // are about the same, maxNum === sectionsLength doesn't work\n  } else if (maxSections > sectionsLength || sectionsLength - maxSections < 0.01) {\n    if (sectionsPerTruncation > 1) {\n      setSectionsPerTruncation(1);\n      setCurrent(firstSectionKey);\n    }\n\n    // need truncation\n  } else {\n    const tempSectionCount = findSectionCount(maxSections, last);\n    if (tempSectionCount !== sectionsPerTruncation && tempSectionCount < sectionsLength) {\n      setSectionsPerTruncation(tempSectionCount);\n      setCurrent(firstSectionKey);\n    }\n  }\n};\n\n/**\n * A helper function to find the best section count\n * in a truncation\n *\n * @param maxSections maximum number of sections allowed in a truncation\n * @param last the index of last section\n */\nconst findSectionCount = (maxSections: number, last: number) => {\n  // need truncation\n  maxSections -= 2; // minus the last character and the others character\n  maxSections /= 2; // each truncation has a section and a separator\n\n  const newSectionCount = Math.round(last / maxSections) + 1;\n  const truncationLeftover = last % newSectionCount;\n  const truncationCount = Math.floor(last / newSectionCount) + (truncationLeftover > 1 ? 1 : 0);\n\n  // When the sectionCount becomes greater, it will result in\n  // same truncations but with different sections appearing.\n  // The following is to find the best sectionCount in this case\n  // and prevent unnecessary truncations.\n  let tempLeftover = last - (truncationCount - 1) * newSectionCount;\n  let tempSectionCount = newSectionCount;\n  while (tempSectionCount > tempLeftover) {\n    tempSectionCount -= 1;\n    tempLeftover = last - (truncationCount - 1) * tempSectionCount;\n  }\n  if (tempSectionCount != newSectionCount) {\n    tempSectionCount += 1;\n  }\n\n  return tempSectionCount;\n};\n\n/**\n * Helper function to find the aria description for Indexer,\n * based on whether current device is a mobile device\n */\nfunction getIndexerDescription(translations: any) {\n  const deviceType = getClientHints().deviceType;\n  if (deviceType === 'phone' || deviceType === 'tablet') {\n    return translations.indexer_touchInstructionText();\n  } else {\n    return translations.indexer_keyboardInstructionText();\n  }\n}\n"],"names":["SECTION_OTHERS","Object","freeze","key","label","liStyles","ITEM_SELECTOR","dotStyles","SectionItem","forwardRef","props","ref","translations","useTranslationBundle","context","selectedKey","commonProps","class","data","isDisabled","sectionLabel","valueText","indexer_disabledLabel","SECTION","_jsx","assign","itemClasses","children","getCommonProps","currentKey","valueNow","isFocusRingVisible","classes","classNames","isCurrent","LastSectionItem","_a","lastValueNow","sectionProps","__rest","_jsxs","Fragment","OthersItem","index","othersClasses","isSelected","othersValueText","SeparatorItem","sections","fromText","from","toText","to","separatorValueText","indexer_separatorLabel","getSeparatorRange","sectionsPerTruncation","last","isInSeparatorMiddle","Math","floor","styles","ulStyles","defaultSections","handleKeyExtract","element","rootRef","current","keyExtractor","handleSelection","detail","onCommit","value","find","section","updateSectionsPerTruncation","height","itemHeight","sectionsLength","firstSectionKey","setSectionsPerTruncation","setCurrent","maxSections","tempSectionCount","findSectionCount","newSectionCount","round","truncationLeftover","getIndexerDescription","deviceType","getClientHints","indexer_touchInstructionText","indexer_keyboardInstructionText","useRef","ulRef","currElementRef","createRef","useState","renderedSectionsCount","itemHeightRef","uniqueId","useId","contains","elem","selectionProps","useSingleSelection","undefined","handleResize","useCallback","entries","entry","contentRect","length","setAttribute","root","querySelector","offsetHeight","resizeObserver","observe","unobserve","jsx","Flex","align","width","mergeProps","currentKeyProps","focusRingProps","tabIndex","role","Collection","items","hasSeparator","separatorProps","HiddenAccessible","id"],"mappings":"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"}