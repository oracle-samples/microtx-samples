{"version":3,"file":"FocusTrap-b42970ea.js","sources":["../../src/UNSAFE_FocusTrap/FocusGuard.tsx","../../src/UNSAFE_FocusTrap/FocusTrap.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { cssProps } from '@oracle/oraclejet-cssprops';\n\ntype Props = {\n  onFocus: (event: FocusEvent) => void;\n};\n\nconst styles = {\n  guard: cssProps`${{\n    height: '0px',\n    left: 0,\n    position: 'fixed',\n    top: 0,\n    width: '1px'\n  }}`\n};\n\n/**\n * Styled FocusTrap sub-component to render non-visible focus guards\n */\nconst FocusGuard = forwardRef(({ onFocus }: Props, guardRef: ForwardedRef<HTMLDivElement>) => {\n  return <div class={styles.guard} onFocus={onFocus} ref={guardRef} tabIndex={0} />;\n});\n\nexport default FocusGuard;\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren, Fragment, RefObject } from 'preact';\nimport { useCallback, useEffect, useRef } from 'preact/compat';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { cssProps } from '@oracle/oraclejet-cssprops';\nimport {\n  focusOn,\n  focusOnEnd,\n  focusOnStart,\n  focusWithin,\n  getActiveElement,\n  isTabbableElement\n} from '../utils/PRIVATE_tabbableUtils';\nimport FocusGuard from './FocusGuard';\n\ntype Props = {\n  children: ComponentChildren;\n  /**\n   * Optional Ref to an element to focus on when component mounts\n   * @default - undefined - behavior is to focus on first tabbableElement\n   */\n  autoFocusRef?: RefObject<HTMLElement | null>;\n\n  /**\n   * Sets whether focus is managed and whether guards are present\n   * @default false\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Why a isDisabled prop as compared to ONLY supporting conditional rendering?\n   *\n   *   1) We need an actual HTML Element for the trap, conditional rendering an element potentially breaks consumer CSS\n   *   2) Conditional rendering can short-circuit event bubbling in preact and lead to expected events not bubbling.\n   */\n\n  /**\n   * Optional Ref to element to focus on when component un-mounts, false to disable.\n   * @default - undefined - behavior is to focus on the original activeElement when focus trap was enabled\n   */\n  restoreFocusRef?: RefObject<HTMLElement> | false;\n};\n\n/**\n * Trap focus within a DOM node.  When a user hits Tab or Shift+Tab, focus remains in the focus trap.\n */\nexport const FocusTrap = ({\n  autoFocusRef,\n  children,\n  isDisabled = false,\n  restoreFocusRef\n}: Props) => {\n  const trapRef = useRef<HTMLDivElement>(null);\n  const startGuardRef = useRef<HTMLDivElement>(null);\n  const endGuardRef = useRef<HTMLDivElement>(null);\n  const lastActiveElementRef = useRef<HTMLElement | null>(null);\n\n  // classes to be set on the children wrapper\n  const classes = classNames([childrenStyles]);\n\n  /**\n   * contain focus if trap is enabled, and target is not already contained\n   *\n   * calling cases for side-effect of setting focus\n   *   - on initial mount of (enabled) trap, where target is not inside trap\n   *   - on enabling of a disabled trap, where target is not inside trap\n   *   - target of click event is outside of trap.\n   */\n  const conditionallyContainFocus = useCallback(\n    (target: HTMLElement | null) => {\n      const trap = trapRef.current;\n      //  short-circuit, if trap or target not valid\n      if (isDisabled || !trap || !target) return;\n\n      // just update ref if, target already has focus\n      if (target && hasFocus([trap, startGuardRef.current, endGuardRef.current], target)) {\n        lastActiveElementRef.current = target;\n        return;\n      }\n\n      // set focus to last active tab-stop if lastElement is defined and inside trap\n      if (lastActiveElementRef.current) {\n        focusOn(lastActiveElementRef.current);\n      } else {\n        // otherwise just contain focus within trap as target is outside enabled trap and we have no last-known tab-stop\n        focusWithin(trap);\n      }\n    },\n    [isDisabled]\n  );\n\n  // loop focus\n  const handleStartGuardOnFocus = (event: FocusEvent) => {\n    if (isDisabled || !trapRef.current) return;\n    focusOnEnd(trapRef.current);\n\n    // prevent scroll jump and bubbling this event up as a focus event\n    event.stopPropagation();\n    event.preventDefault();\n  };\n\n  const handleEndGuardOnFocus = (event: FocusEvent) => {\n    if (isDisabled || !trapRef.current) return;\n    focusOnStart(trapRef.current);\n\n    // prevent scroll jump and bubbling guard event up as a focus event\n    event.stopPropagation();\n    event.preventDefault();\n  };\n\n  const handleTrapOnFocus = (event: FocusEvent) => {\n    lastActiveElementRef.current = event.target as HTMLElement;\n  };\n\n  // handle initial render or re-render as enabled\n  useEffect(() => {\n    const trap = trapRef.current;\n    if (!trap || isDisabled) return;\n\n    const originalActiveElement = getActiveElement(trap);\n\n    // init focus\n    if (autoFocusRef && autoFocusRef.current) {\n      focusOn(autoFocusRef.current);\n    } else {\n      conditionallyContainFocus(originalActiveElement);\n    }\n\n    const restoreFocusRefForCleanup = restoreFocusRef;\n\n    return () => {\n      if (restoreFocusRefForCleanup === false) return;\n      restoreFocusAfterUnmount(restoreFocusRefForCleanup?.current || originalActiveElement);\n    };\n  }, [autoFocusRef, conditionallyContainFocus, isDisabled, restoreFocusRef]);\n\n  return (\n    <Fragment>\n      {!isDisabled && <FocusGuard onFocus={handleStartGuardOnFocus} ref={startGuardRef} />}\n      <div onFocus={handleTrapOnFocus} ref={trapRef} class={classes}>\n        {children}\n      </div>\n      {!isDisabled && <FocusGuard onFocus={handleEndGuardOnFocus} ref={endGuardRef} />}\n    </Fragment>\n  );\n};\n\n// setTimeout ensures that unmount lifecycle has completed\nconst restoreFocusAfterUnmount = (element: HTMLElement | null) => {\n  if (element && isTabbableElement(element)) {\n    setTimeout(() => {\n      focusOn(element);\n    }, 0);\n  }\n};\n\n// is focus already contained?\nconst hasFocus = (elements: (HTMLElement | null)[], target: Element) => {\n  if (elements.length === 0) return false;\n  const activeElement = target ?? getActiveElement(elements[0] as Node);\n  return elements.some((el) => el === activeElement || el?.contains(activeElement));\n};\n\n// remove margins from children\nconst childrenStyles = cssProps`${{\n  /* @ts-ignore */\n  '& > *': {\n    marginTop: '0 !important',\n    marginBottom: '0 !important',\n    marginLeft: '0 !important',\n    marginRight: '0 !important'\n  }\n}}`;\n"],"names":["styles","FocusGuard","forwardRef","onFocus","guardRef","_jsx","class","ref","tabIndex","restoreFocusAfterUnmount","element","isTabbableElement","hasFocus","elements","target","length","activeElement","getActiveElement","childrenStyles","autoFocusRef","children","isDisabled","restoreFocusRef","trapRef","useRef","startGuardRef","endGuardRef","lastActiveElementRef","conditionallyContainFocus","useCallback","trap","current","focusOn","originalActiveElement","restoreFocusRefForCleanup","event","focusOnEnd","focusOnStart"],"mappings":"sMAeA,MAAAA,YAaAC,EAAAC,EAAAA,WAAA,EAAAC,QAAAA,GAAAC,IACEC,EAAAA,IAAA,MAAA,CAAAC,MAAAN,EAAAG,QAAAA,EAAAI,IAAAH,EAAAI,SAAA,KC6HFC,EAAAC,IACEA,GAAAC,oBAAAD,sCAQFE,EAAA,CAAAC,EAAAC,KACE,GAAA,IAAAD,EAAAE,OAA2B,OAAA,EAC3B,MAAAC,EAAAF,MAAAA,EAAAA,EAAAG,EAAAA,iBAAAJ,EAAA,6DAKFK,EAAA,qBAtHA,EAAAC,aAAAA,EAAAC,SAAAA,EAAAC,WAAAA,GAAA,EAAAC,gBAAAA,MAME,MAAAC,EAAAC,SAAA,MACAC,EAAAD,SAAA,MACAE,EAAAF,SAAA,MACAG,EAAAH,SAAA,0BAaAI,EAAAC,EAAAA,YAAAf,IAEI,MAAAgB,EAAAP,EAAAQ,SAEAV,GAAAS,GAAAhB,IAGAA,GAAAF,EAAA,CAAAkB,EAAAL,EAAAM,QAAAL,EAAAK,SAAAjB,GACEa,EAAAI,QAAAjB,YAMAkB,UAAAL,EAAAI,4BAKJ,CAAAV,4BA6BA,MAAAS,EAAAP,EAAAQ,wBAGA,MAAAE,EAAAhB,mBAAAa,GAGAX,GAAAA,EAAAY,QACEC,UAAAb,EAAAY,wBAOF,MAAA,aAEEtB,GAAAyB,MAAAA,OAAA,EAAAA,EAAAH,UAAAE,kEAxCJE,KACEd,GAAAE,EAAAQ,UACAK,aAAAb,EAAAQ,6FAgBFI,IACER,EAAAI,QAAAI,EAAArB,2DAVFqB,KACEd,GAAAE,EAAAQ,UACAM,eAAAd,EAAAQ"}