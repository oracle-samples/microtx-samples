{"version":3,"file":"UNSAFE_usePan.js","sources":["../../../src/hooks/UNSAFE_usePan/usePan.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useRef, useCallback } from 'preact/hooks';\n\n/*\nthreshold: Minimal distance in pixels required before recognizing\n*/\ntype PanOptions = {\n  threshold?: number;\n  minimumTime?: number;\n  isDisabled?: boolean;\n};\n\ntype PanInfo = {\n  x: number;\n  y: number;\n  status: 'start' | 'end' | 'move';\n};\n\ntype PanState = {\n  pointerDownId: number | null;\n  startTime: number | null;\n  prevOffsetX: number;\n  prevOffsetY: number;\n};\n\nexport function usePan(\n  onPan: (e: PanInfo) => void,\n  { threshold = 50, minimumTime = 500, isDisabled = false }: PanOptions = {\n    threshold: 50,\n    minimumTime: 500,\n    isDisabled: false\n  }\n): { panProps: Record<string, any> } {\n  const ref = useRef<PanState>({\n    pointerDownId: 0,\n    startTime: 0,\n    prevOffsetX: 0,\n    prevOffsetY: 0\n  });\n\n  const onPointerDown = useCallback((e: PointerEvent) => {\n    if (!ref.current.pointerDownId) {\n      ref.current = {\n        pointerDownId: e.pointerId,\n        startTime: e.timeStamp,\n        prevOffsetX: e.offsetX,\n        prevOffsetY: e.offsetY\n      };\n      onPan?.({ x: e.clientX, y: e.clientY, status: 'start' });\n    } else {\n      clearPan();\n    }\n  }, []);\n\n  const onPointerMove = (e: PointerEvent) => {\n    if (ref.current.pointerDownId === e.pointerId) {\n      onPan?.({ x: e.clientX, y: e.clientY, status: 'move' });\n    }\n  };\n\n  const onPointerUp = useCallback(\n    (ev: PointerEvent) => {\n      if (ev.pointerId === ref.current.pointerDownId) {\n        if (ref.current.startTime && ev.timeStamp - ref.current.startTime >= minimumTime) {\n          const horizontalThreshold = ev.offsetX - ref.current.prevOffsetX;\n          const verticalThreshold = ev.offsetY - ref.current.prevOffsetY;\n          if (Math.abs(horizontalThreshold) > Math.abs(verticalThreshold)) {\n            // pan-left or pan-right\n            if (ref.current.prevOffsetX - ev.offsetX > threshold) {\n              onPan?.({ x: ev.clientX, y: ev.clientY, status: 'end' });\n            } else if (ev.offsetX - ref.current.prevOffsetX > threshold) {\n              onPan?.({ x: ev.clientX, y: ev.clientY, status: 'end' });\n            }\n          } else {\n            // pan-up or pan-down\n            if (ref.current.prevOffsetY - ev.offsetY > threshold) {\n              onPan?.({ x: ev.clientX, y: ev.clientY, status: 'end' });\n            } else if (ev.offsetY - ref.current.prevOffsetY > threshold) {\n              onPan?.({ x: ev.clientX, y: ev.clientY, status: 'end' });\n            }\n          }\n        }\n      }\n      // state would be reset to its original state whether pan is completed or cancelled\n      clearPan();\n    },\n    [threshold, onPan]\n  );\n\n  const clearPan = useCallback(() => {\n    ref.current = {\n      pointerDownId: null,\n      startTime: null,\n      prevOffsetX: 0,\n      prevOffsetY: 0\n    };\n  }, []);\n\n  const panProps = isDisabled\n    ? {}\n    : {\n        /** event handlers to spread on the target element. */\n        onPointerDown,\n        onPointerUp,\n        onPointerMove,\n        onPointerCancel: clearPan\n      };\n\n  return {\n    panProps\n  };\n}\n"],"names":["onPan","threshold","minimumTime","isDisabled","ref","useRef","pointerDownId","startTime","prevOffsetX","prevOffsetY","onPointerDown","useCallback","e","current","clearPan","pointerId","timeStamp","offsetX","offsetY","x","clientX","y","clientY","status","onPointerUp","ev","horizontalThreshold","verticalThreshold","Math","abs","panProps","onPointerMove","onPointerCancel"],"mappings":"+EAiCEA,GACAC,UAAEA,EAAY,GAAdC,YAAkBA,EAAc,IAAhCC,WAAqCA,GAAa,GAAsB,CACtEF,UAAW,GACXC,YAAa,IACbC,YAAY,IAGd,MAAMC,EAAMC,EAAAA,OAAiB,CAC3BC,cAAe,EACfC,UAAW,EACXC,YAAa,EACbC,YAAa,IAGTC,EAAgBC,cAAaC,IAC5BR,EAAIS,QAAQP,cASfQ,KARAV,EAAIS,QAAU,CACZP,cAAeM,EAAEG,UACjBR,UAAWK,EAAEI,UACbR,YAAaI,EAAEK,QACfR,YAAaG,EAAEM,SAEjBlB,MAAAA,GAAAA,EAAQ,CAAEmB,EAAGP,EAAEQ,QAASC,EAAGT,EAAEU,QAASC,OAAQ,YAI/C,IAQGC,EAAcb,cACjBc,IACC,GAAIA,EAAGV,YAAcX,EAAIS,QAAQP,eAC3BF,EAAIS,QAAQN,WAAakB,EAAGT,UAAYZ,EAAIS,QAAQN,WAAaL,EAAa,CAChF,MAAMwB,EAAsBD,EAAGR,QAAUb,EAAIS,QAAQL,YAC/CmB,EAAoBF,EAAGP,QAAUd,EAAIS,QAAQJ,YAC/CmB,KAAKC,IAAIH,GAAuBE,KAAKC,IAAIF,IAEvCvB,EAAIS,QAAQL,YAAciB,EAAGR,QAAUhB,GAEhCwB,EAAGR,QAAUb,EAAIS,QAAQL,YAAcP,KADhDD,MAAAA,GAAAA,EAAQ,CAAEmB,EAAGM,EAAGL,QAASC,EAAGI,EAAGH,QAASC,OAAQ,UAM9CnB,EAAIS,QAAQJ,YAAcgB,EAAGP,QAAUjB,GAEhCwB,EAAGP,QAAUd,EAAIS,QAAQJ,YAAcR,KADhDD,MAAAA,GAAAA,EAAQ,CAAEmB,EAAGM,EAAGL,QAASC,EAAGI,EAAGH,QAASC,OAAQ,SAQxDT,KAEF,CAACb,EAAWD,IAGRc,EAAWH,EAAAA,YAAY,KAC3BP,EAAIS,QAAU,CACZP,cAAe,KACfC,UAAW,KACXC,YAAa,EACbC,YAAa,IAEd,IAYH,MAAO,CACLqB,SAXe3B,EACb,GACA,CAEEO,cAAAA,EACAc,YAAAA,EACAO,cAlDiBnB,IACjBR,EAAIS,QAAQP,gBAAkBM,EAAEG,YAClCf,MAAAA,GAAAA,EAAQ,CAAEmB,EAAGP,EAAEQ,QAASC,EAAGT,EAAEU,QAASC,OAAQ,WAiD5CS,gBAAiBlB"}