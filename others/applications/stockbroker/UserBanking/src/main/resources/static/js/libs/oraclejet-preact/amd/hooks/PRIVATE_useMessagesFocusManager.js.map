{"version":3,"file":"PRIVATE_useMessagesFocusManager.js","sources":["../../../src/hooks/PRIVATE_useMessagesFocusManager/useMessagesFocusManager.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { RefObject } from 'preact';\nimport { useEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport { HTMLAttributesSignalExcluded } from '../../utils/UNSAFE_attributeUtils';\n\nexport type FocusableComponentHandle = {\n  focus: () => boolean;\n  contains: (element: HTMLElement) => boolean;\n};\n\ntype FocusableComponentCallbacks = {\n  onFocus?: () => void;\n  onFocusLeave?: () => void;\n};\n\ntype FocusManagerHandlers = Pick<\n  HTMLAttributesSignalExcluded,\n  'onfocusin' | 'onfocusout' | 'onKeyUp'\n>;\n\ntype ComponentOptions = {\n  ref: RefObject<FocusableComponentHandle>;\n  callbacks?: FocusableComponentCallbacks;\n};\n\ntype FocusManagerOptions = {\n  handleEscapeKey?: boolean;\n};\n\nconst componentsMap = new Map<symbol, ComponentOptions>();\nconst componentsOrder = [] as symbol[];\nconst priorFocusCache = new Map<symbol, Node>();\nlet hasDocumentListener = false;\nlet priorFocusedElement: HTMLElement;\nlet currentFocusedMessage: symbol | undefined;\n\n/**\n * Handles KeyDown event in the document element during the capture phase.\n *\n * @param event The keydown event object\n */\nfunction handleDocumentKeyDownCapture(event: KeyboardEvent) {\n  // Do nothing if any of the following is true:\n  // 1. No components are registered\n  // 2. Pressed key is not F6\n  // 3. Event is defaultPrevented\n  if (componentsMap.size === 0 || event.key !== 'F6' || event.defaultPrevented) {\n    return;\n  }\n\n  // Try cycling focus through the messages and if that fails\n  // set the focus to the prior focused element.\n  if (!cycleFocusThroughMessages(event)) {\n    currentFocusedMessage && togglePreviousFocus(currentFocusedMessage, event);\n  }\n}\n\n/**\n * Handles the blur event captured on the document\n * @param event Blur event object\n */\nfunction handleDocumentBlurCapture(event: FocusEvent) {\n  priorFocusedElement = event.target as HTMLElement;\n}\n\n/**\n * Handles the keyup event in the component\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The keyup event object\n */\nfunction handleComponentKeyUp(id: symbol, event: KeyboardEvent) {\n  // Ignore the call if the comp is not registered anymore or event default is prevented\n  if (!componentsMap.has(id) || event.defaultPrevented) {\n    return;\n  }\n\n  // Additional checks for keyup event and recognized keys\n  if (event.type === 'keyup' && ['Escape'].includes(event.key)) {\n    // toggle focus to the previously focused element\n    togglePreviousFocus(id, event);\n  }\n}\n\n/**\n * Handles the focus event in the component\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The focus event object\n */\nfunction handleComponentFocus(id: symbol, event: FocusEvent) {\n  // Ignore the call if the comp is not registered anymore or event default is prevented\n  if (!componentsMap.has(id) || event.defaultPrevented) {\n    return;\n  }\n\n  // Store the id of the current focused message\n  currentFocusedMessage = id;\n\n  // Track previous focus if the priorFocused element is not a part of this or any other\n  // registered component\n  const { callbacks } = componentsMap.get(id)!;\n  if (priorFocusedElement && !isPartOfRegisteredMessages(priorFocusedElement)) {\n    priorFocusCache.set(id, priorFocusedElement!);\n\n    // since the focus moved to this component from outside, call the\n    // onFocus callbacks if available\n    callbacks?.onFocus?.();\n  }\n}\n\n/**\n * Handles the blur event in the component\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The focus event object\n */\nfunction handleComponentBlur(id: symbol, event: FocusEvent) {\n  // Ignore the call if the comp is not registered anymore or event default is prevented\n  if (!componentsMap.has(id) || event.defaultPrevented) {\n    return;\n  }\n\n  // reset the current focus message ID\n  currentFocusedMessage = undefined;\n}\n\n/**\n * Cycles the focus through the registered messages component from the previous message of current focused\n * message to the top of the hierarchy.\n *\n * @param event The event that initiated this action\n * @returns boolean indicating the result of this action\n */\nfunction cycleFocusThroughMessages(event: Event) {\n  // At this point, we need to focus the previous message from the current focused\n  // message\n  const nextPosition =\n    indexOfOrDefaultTo(componentsOrder, currentFocusedMessage, componentsOrder.length) - 1;\n  for (let i = nextPosition; i > -1; i--) {\n    const id = componentsOrder[i];\n    const { ref } = componentsMap.get(id) ?? {};\n    if (ref?.current?.focus?.()) {\n      // prevent default action as the event has transferred focus\n      event.preventDefault();\n      // invoke callback to let the current component know the focus is left\n      if (currentFocusedMessage) {\n        const { callbacks } = componentsMap.get(currentFocusedMessage) ?? {};\n        callbacks?.onFocusLeave?.();\n      }\n      // Focus is set, so break the loop\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Checks if the provided element is a part of any of the registered messages\n *\n * @param element The candidate element\n * @returns true if is inside any of the registered messages\n */\nfunction isPartOfRegisteredMessages(element: HTMLElement) {\n  for (const { ref } of componentsMap.values()) {\n    if (ref.current?.contains(element)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Finds the index of the item in the array, if it does not exist returns the\n * default value instead\n *\n * @param arr The array to perform the search\n * @param search The item to be searched\n * @param defaultIndex The default value if the item is not found\n * @returns The index of the item or the default value\n */\nfunction indexOfOrDefaultTo<T>(arr: T[], search: T, defaultIndex = -1) {\n  const index = arr.indexOf(search);\n  if (index !== -1) return index;\n  return defaultIndex;\n}\n\n/**\n * Traverses through the priorFocusCache to fetch the last focused\n * element outside of the messages region.\n *\n * @param id The current focused message's ID\n * @returns The closest prior focused element, null if not found\n */\nfunction getClosestPriorFocusedElement(id: symbol) {\n  // F6 navigation cycles through messages in reverse order\n  // so to get the closest prior focused element we need to\n  // traverse in natural order from the current message\n  const index = componentsOrder.indexOf(id);\n  for (let i = index; i < componentsOrder.length; i++) {\n    if (priorFocusCache.has(componentsOrder[i])) {\n      return priorFocusCache.get(componentsOrder[i])!;\n    }\n  }\n\n  // No prior cache found, so return null\n  return null;\n}\n\n/**\n * Adds the component to the internal members.\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param ref A ref handle to the focusable component\n * @param callbacks Optional callbacks\n */\nfunction addComponent(id: symbol, options: ComponentOptions) {\n  componentsMap.set(id, options);\n  componentsOrder.push(id);\n}\n\n/**\n * Removes the component from the internal members\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n */\nfunction removeComponent(id: symbol) {\n  if (!componentsMap.has(id)) {\n    return;\n  }\n\n  componentsMap.delete(id);\n  componentsOrder.splice(componentsOrder.indexOf(id), 1);\n}\n\n/**\n * Clears the priorFocusCache of the specified component\n *\n * @param id The id of the component whose cache is to be cleared\n */\nfunction clearFocusCache(id: symbol) {\n  priorFocusCache.delete(id);\n}\n\n/**\n * Adds event listeners to the document element\n */\nfunction addDocumentListeners() {\n  // Add the events in capture phase, as we do not want this to be stopped by the elements\n  // in the DOM tree.\n  // make sure to use keydown as we need to prevent the default behavior which is moving to\n  // the address bar in some browsers & OS.\n  document.documentElement.addEventListener('keydown', handleDocumentKeyDownCapture, true);\n  document.documentElement.addEventListener('blur', handleDocumentBlurCapture, true);\n  hasDocumentListener = true;\n}\n\n/**\n * Removes event listeners from the document element\n */\nfunction removeDocumentListeners() {\n  document.documentElement.removeEventListener('keydown', handleDocumentKeyDownCapture, true);\n  document.documentElement.removeEventListener('blur', handleDocumentBlurCapture, true);\n  hasDocumentListener = false;\n}\n\n/**\n * Registers a component for its focus to be managed.\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param componentOptions An object containing component options\n * @param focusManagerOptions An object containing focus manager options\n *\n * @returns An object containing focus event listeners\n */\nfunction register(\n  id: symbol,\n  componentOptions: ComponentOptions,\n  focusManagerOptions: FocusManagerOptions = { handleEscapeKey: true }\n) {\n  if (!hasDocumentListener) {\n    addDocumentListeners();\n  }\n\n  addComponent(id, componentOptions);\n  const handlers: FocusManagerHandlers = {\n    onfocusin: (event: FocusEvent) => handleComponentFocus(id, event),\n    onfocusout: (event: FocusEvent) => handleComponentBlur(id, event)\n  };\n  if (focusManagerOptions.handleEscapeKey) {\n    handlers['onKeyUp'] = (event: KeyboardEvent) => handleComponentKeyUp(id, event);\n  }\n  return handlers;\n}\n\n/**\n * Focuses the element which was focused prior to the passed component.\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The event that initiated the focus transfer. The event will be default prevented if the focus\n *              is transferred successfully.\n * @returns true, if focus is restored. false otherwise.\n */\nfunction togglePreviousFocus(id: symbol, event?: Event) {\n  const target = getClosestPriorFocusedElement(id);\n  const { callbacks } = componentsMap.get(id) ?? {};\n  if (target && document.body.contains(target)) {\n    (target as HTMLElement).focus();\n    // invoke callback to let the component know the focus is left\n    callbacks?.onFocusLeave?.();\n    // As the prior focus is restored, empty the focus cache\n    priorFocusCache.clear();\n    event?.preventDefault();\n    return true;\n  }\n\n  // Prior focused element does not exist or\n  // Element does not exist in DOM.\n  return false;\n}\n\n/**\n * Unregisters a component from focus management\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n */\nfunction unregister(id: symbol) {\n  removeComponent(id);\n  clearFocusCache(id);\n\n  if (hasDocumentListener && componentsMap.size === 0) {\n    // no component is registered, so remove the document listeners\n    removeDocumentListeners();\n  }\n}\n\n/**\n * Moves the priority of the component with the specified id\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n */\nfunction prioritize(id: symbol) {\n  if (!componentsMap.has(id)) {\n    // Do nothing if the component is not registered\n    return;\n  }\n\n  // Remove and add the component with the same ref\n  // to move it in the priority queue\n  const options = componentsMap.get(id)!;\n  removeComponent(id);\n  addComponent(id, options);\n}\n\n/**\n * The focus manager object\n */\nconst messagesFocusManager = {\n  prioritize,\n  register,\n  togglePreviousFocus,\n  unregister\n};\n\n/**\n * A custom hook that handles focus management for the messages component.\n * @param ref The custom ref handle for the component\n * @param callbacks Optional callbacks\n * @returns The handlers and a controller\n */\nexport function useMessageFocusManager(\n  ref: ComponentOptions['ref'],\n  callbacks?: ComponentOptions['callbacks'],\n  options?: FocusManagerOptions\n) {\n  const id = useRef(Symbol());\n  const focusManager = useRef(messagesFocusManager);\n  const [handlers, setHandlers] = useState<FocusManagerHandlers>({});\n  const controller = useMemo(\n    () => ({\n      prioritize: () => focusManager.current.prioritize(id.current),\n      restorePriorFocus: () => focusManager.current.togglePreviousFocus(id.current)\n    }),\n    []\n  );\n\n  // Register handlers for focus management\n  useEffect(() => {\n    const currentFocusManager = focusManager.current;\n    const currentId = id.current;\n    setHandlers(currentFocusManager.register(currentId, { ref, callbacks }, options));\n    return () => currentFocusManager.unregister(currentId);\n    // eslint-disable-next-line\n  }, []); // we only want this to run on mount\n\n  return {\n    handlers,\n    controller\n  };\n}\n"],"names":["componentsMap","Map","componentsOrder","priorFocusCache","priorFocusedElement","currentFocusedMessage","hasDocumentListener","handleDocumentKeyDownCapture","event","size","key","defaultPrevented","i","arr","search","defaultIndex","index","indexOf","indexOfOrDefaultTo","length","id","ref","_a","get","_c","_b","current","focus","call","preventDefault","callbacks","_d","_e","onFocusLeave","cycleFocusThroughMessages","togglePreviousFocus","handleDocumentBlurCapture","target","handleComponentFocus","has","element","values","contains","isPartOfRegisteredMessages","set","onFocus","addComponent","options","push","removeComponent","delete","splice","getClosestPriorFocusedElement","document","body","clear","messagesFocusManager","prioritize","register","componentOptions","focusManagerOptions","handleEscapeKey","documentElement","addEventListener","handlers","onfocusin","onfocusout","undefined","handleComponentBlur","type","includes","handleComponentKeyUp","unregister","clearFocusCache","removeEventListener","useRef","Symbol","focusManager","setHandlers","useState","controller","useMemo","restorePriorFocus","useEffect","currentFocusManager","currentId"],"mappings":"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"}