{"version":3,"file":"UNSAFE_usePrefixSuffix.js","sources":["../../../src/hooks/UNSAFE_usePrefixSuffix/usePrefixSuffix.tsx"],"sourcesContent":["import { PrefixSuffix } from '../../UNSAFE_PrefixSuffix';\nimport { useUser } from '../UNSAFE_useUser';\n\ntype Props = {\n  baseId: string;\n  hasEndContent?: boolean;\n  hasInsideLabel?: boolean;\n  hasStartContent?: boolean;\n  hasValue?: boolean;\n  isDisabled?: boolean;\n  isFocused?: boolean;\n  labelId?: string;\n  prefix?: string;\n  suffix?: string;\n  value?: string;\n};\n\n// returns the prefix and/or suffix components\n// if the condition in which they should be shown is met.\nexport const usePrefixSuffix = ({\n  baseId,\n  hasEndContent,\n  hasInsideLabel,\n  hasStartContent,\n  hasValue,\n  isDisabled,\n  isFocused,\n  labelId,\n  prefix,\n  suffix,\n  value\n}: Props) => {\n  const { direction } = useUser();\n  // for accessibility, if you have a prefix, then you must have a prefixId\n  const prefixId = `${baseId}-prefix`;\n  const suffixId = `${baseId}-suffix`;\n  const hasPrefixText = prefix !== undefined && prefix !== '';\n  const hasSuffixText = suffix !== undefined && suffix !== '';\n\n  const renderedPrefix =\n    hasPrefixText && !isDisabled && (hasValue || isFocused) ? (\n      <PrefixSuffix\n        id={prefixId}\n        hasEndContent={hasEndContent}\n        hasInsideLabel={hasInsideLabel}\n        hasStartContent={hasStartContent}\n        isDisabled={isDisabled}\n        isFocused={isFocused}\n        text={prefix}\n        variant=\"prefix\"\n      />\n    ) : undefined;\n\n  const renderedSuffix =\n    hasSuffixText && !isDisabled && (hasValue || isFocused) ? (\n      <PrefixSuffix\n        id={suffixId}\n        hasInsideLabel={hasInsideLabel}\n        isDisabled={isDisabled}\n        isFocused={isFocused}\n        text={suffix}\n        variant=\"suffix\"\n      />\n    ) : undefined;\n\n  // get value and prefix/suffix if available and return as plain text.\n  const text =\n    hasPrefixText || hasSuffixText ? getText(direction, hasValue, prefix, suffix, value) : value;\n  // get aria-labelledby if there is a prefix or suffix\n  const ariaLabelledBy =\n    hasPrefixText || hasSuffixText\n      ? getAriaLabelledBy(\n          labelId,\n          hasPrefixText ? prefixId : undefined,\n          hasSuffixText ? suffixId : undefined\n        )\n      : undefined;\n\n  return { renderedPrefix, renderedSuffix, text, ariaLabelledBy };\n};\n\n/**\n * Returns the value to render in plain text, taking into account the prefix and suffix\n * and reading direction. Do not add a prefix/suffix if the component doesn't have a value.\n * @returns string | undefined\n */\nfunction getText(\n  direction: 'ltr' | 'rtl',\n  hasValue?: boolean,\n  prefix?: string,\n  suffix?: string,\n  value?: string\n) {\n  // Do not add a prefix/suffix if the component doesn't have a value.\n  if (!hasValue) {\n    return value;\n  }\n  // TODO: direction is 'ltr' even though the storybook is rtl.\n  // Test this when the storybook bug is fixed. https://jira.oraclecorp.com/jira/browse/JET-51816?src=confmacro\n  const isLTR = direction === 'ltr';\n  const plainPrefix = prefix === undefined ? `` : isLTR ? `${prefix} ` : ` ${prefix}`;\n  const plainSuffix = suffix === undefined ? `` : isLTR ? ` ${suffix}` : `${suffix} `;\n\n  const ltrPlainText = `${plainPrefix}${value}${plainSuffix}`;\n  const rtlPlainText = `${plainSuffix}${value}${plainPrefix}`;\n  return isLTR ? ltrPlainText : rtlPlainText;\n}\n\nfunction getAriaLabelledBy(labelId?: string, prefixId?: string, suffixId?: string) {\n  const label = labelId ?? '';\n  const prefix = prefixId === undefined ? '' : label.length === 0 ? prefixId : ` ${prefixId}`;\n  const suffix =\n    suffixId === undefined\n      ? ''\n      : label.length === 0 && prefix.length === 0\n      ? suffixId\n      : ` ${suffixId}`;\n  const ariaLabelledBy = `${label}${prefix}${suffix}`;\n  return ariaLabelledBy.length === 0 ? undefined : ariaLabelledBy;\n}\n"],"names":["baseId","hasEndContent","hasInsideLabel","hasStartContent","hasValue","isDisabled","isFocused","labelId","prefix","suffix","value","direction","useUser","prefixId","suffixId","hasPrefixText","undefined","hasSuffixText","renderedPrefix","_jsx","jsx","PrefixSuffix","id","text","variant","renderedSuffix","isLTR","plainPrefix","plainSuffix","ltrPlainText","rtlPlainText","getText","ariaLabelledBy","label","length","getAriaLabelledBy"],"mappings":"uSAmB+B,EAC7BA,OAAAA,EACAC,cAAAA,EACAC,eAAAA,EACAC,gBAAAA,EACAC,SAAAA,EACAC,WAAAA,EACAC,UAAAA,EACAC,QAAAA,EACAC,OAAAA,EACAC,OAAAA,EACAC,MAAAA,MAEA,MAAMC,UAAEA,GAAcC,EAAAA,UAEhBC,EAAc,GAAAb,WACdc,EAAc,GAAAd,WACde,OAA2BC,IAAXR,GAAmC,KAAXA,EACxCS,OAA2BD,IAAXP,GAAmC,KAAXA,EAExCS,EACJH,IAAkBV,IAAeD,GAAYE,GAC3Ca,EAACC,IAAAC,EAAYA,aACX,CAAAC,GAAIT,EACJZ,cAAeA,EACfC,eAAgBA,EAChBC,gBAAiBA,EACjBE,WAAYA,EACZC,UAAWA,EACXiB,KAAMf,EACNgB,QAAQ,gBAERR,EAEAS,EACJR,IAAkBZ,IAAeD,GAAYE,GAC3Ca,MAACE,EAAAA,aACC,CAAAC,GAAIR,EACJZ,eAAgBA,EAChBG,WAAYA,EACZC,UAAWA,EACXiB,KAAMd,EACNe,QAAQ,gBAERR,EAGAO,EACJR,GAAiBE,EAmBrB,SACEN,EACAP,EACAI,EACAC,EACAC,GAGA,IAAKN,EACH,OAAOM,EAIT,MAAMgB,EAAsB,QAAdf,EACRgB,OAAyBX,IAAXR,EAAyB,GAAGkB,EAAQ,GAAGlB,KAAY,IAAIA,IACrEoB,OAAyBZ,IAAXP,EAAyB,GAAGiB,EAAQ,IAAIjB,IAAW,GAAGA,KAEpEoB,EAAkB,GAAAF,IAAcjB,IAAQkB,IACxCE,EAAkB,GAAAF,IAAclB,IAAQiB,IAC9C,OAAOD,EAAQG,EAAeC,EAtCKC,CAAQpB,EAAWP,EAAUI,EAAQC,EAAQC,GAASA,EAEnFsB,EACJjB,GAAiBE,EAsCrB,SAA2BV,EAAkBM,EAAmBC,GAC9D,MAAMmB,EAAQ1B,MAAAA,EAAAA,EAAW,GACnBC,OAAsBQ,IAAbH,EAAyB,GAAsB,IAAjBoB,EAAMC,OAAerB,EAAW,IAAIA,IAC3EJ,OACSO,IAAbF,EACI,GACiB,IAAjBmB,EAAMC,QAAkC,IAAlB1B,EAAO0B,OAC7BpB,EACA,IAAIA,IACJkB,EAAoB,GAAAC,IAAQzB,IAASC,IAC3C,OAAiC,IAA1BuB,EAAeE,YAAelB,EAAYgB,EA/C3CG,CACE5B,EACAQ,EAAgBF,OAAWG,EAC3BC,EAAgBH,OAAWE,QAE7BA,EAEN,MAAO,CAAEE,eAAAA,EAAgBO,eAAAA,EAAgBF,KAAAA,EAAMS,eAAAA"}